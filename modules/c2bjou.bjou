# c2bjou
# source to source translator from C to bJou
# uses libclang

module c2bjou

# @hack -- where is this supposed to come from?
abstract type __va_list_tag { }

extern sprintf(char*, char*, ...) : int
extern strcmp(char*, char*) : int
extern strlen(char*) : u64

\ct {
const PRINT_AST := false

import "null.bjou"

import "dict.bjou"

# must be defined for clang.bjou to compile
const libclang_path := "/usr/local/Cellar/llvm/5.0.1/lib/libclang.dylib"
import "clang.bjou"
import "c2bjou/ClangWrapper.bjou"
import "c2bjou/visitors.bjou"

import "compiler.bjou"

proc include(fname : char*) {
    init_clang()

    cw := ClangWrapper.create()
    translator := c2bJou.create(cw)

    translator.cw.parseTU(fname)

    translator.cw.traverseTU(dispatch, (&translator) as CXClientData*)

    # run passes on translated nodes
    gs := bjou_getGlobalScope()

    foreach node in translator.created {
        bjou_appendNode(node)
        bjou_setGlobalNodeRP(node)
    }
    foreach node in translator.structs
        bjou_preDeclare(node, gs)
    foreach node in translator.created
        bjou_addSymbols(node, gs)
    bjou_runTypeCompletion()
    foreach node in translator.created
        bjou_analyze(node)
}

type c2bJou {
    cw            : ClangWrapper ref
    visitor_table : visitor_t[CXCursor_END_]
    indent        : int
    types         : dict$(CXType*, ASTNode*)
    created       : ASTNode*[...]
    structs       : ASTNode*[...]

    proc create(cw : ClangWrapper ref) : c2bJou {
        c := { c2bJou:
            .cw            = cw,
            .indent        = 0,
            .types         = dict$(CXType*, ASTNode*).create(),
            .created       = [...ASTNode*],
            .structs       = [...ASTNode*]
        }

        init_visitor_table(c.visitor_table)

        return c
    }
}
}
