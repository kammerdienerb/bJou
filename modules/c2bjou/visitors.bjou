# visitors.bjou

module c2bjou_visitors

import "clang.bjou"
import "compiler.bjou"

import "dltr.bjou"

type visitor_t = <(CXCursor,      # cursor
                   CXCursor,      # parent
                   CXClientData*) # client_data
                   : u32>

proc child_collector(cursor      : CXCursor,
                     parent      : CXCursor,
                     client_data : CXClientData*) : u32 {

    children := getref(@(client_data as CXCursor[...]*))
    translator := client_data as c2bJou*

    if cursor.kind == CXCursor_CompoundStmt
        translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)   
    else
        children.push(cursor)   

    return CXVisit_Continue
}

proc getCursorContext(cursor : CXCursor) : Context * {
    rng := clang.getCursorExtent(cursor)

    cxf  := (_nullptr() as CXFile*)
    line : u32 = 0
    col  : u32 = 0
    off  : u32 = 0

    _beg := clang.getRangeStart(rng)
    clang.getSpellingLocation(_beg, &cxf, &line, &col, &off)
    beg := { Loc: .line = line, .character = col }
    
    _end := clang.getRangeStart(rng)
    clang.getSpellingLocation(_end, &cxf, &line, &col, &off)
    end := { Loc: .line = line, .character = col + 1 }

    fname := clang.getCString(clang.getFileName(cxf))

    return bjou_createContext(&beg, &end, fname)   
}

proc dispatch(cursor      : CXCursor,
              parent      : CXCursor,
              client_data : CXClientData*) : u32 {

    translator := client_data as c2bJou*

    cursor.clangASTNodePrint(translator)

    visitor := translator.visitor_table[cursor.kind]

    size_before := |translator.created|
    visitor(cursor, parent, client_data)
    size_after := |translator.created|

    if size_after > size_before {
        node := translator.created.back()
        ctx  := getCursorContext(cursor)

        bjou_setContext(node, ctx)

        if cursor.kind == CXCursor_FunctionDecl
            bjou_setProcNameContext(node, ctx)

        else if cursor.kind == CXCursor_VarDecl
        or      cursor.kind == CXCursor_FieldDecl
        or      cursor.kind == CXCursor_ParmDecl
            bjou_setVarDeclNameContext(node, ctx)

        else if cursor.kind == CXCursor_StructDecl
        or      cursor.kind == CXCursor_UnionDecl
            bjou_setStructNameContext(node, ctx)

        else if cursor.kind == CXCursor_TypedefDecl
            bjou_setAliasNameContext(node, ctx)

        bjou_freeContext(ctx)
    }

    return CXVisit_Continue
}

proc init_visitor_table(table : visitor_t[CXCursor_END_]) {
    table.fill(|table|, v_unimplemented)

    table[CXCursor_MacroDefinition]        = v_ignore
    table[CXCursor_InclusionDirective]     = v_ignore
    table[CXCursor_UnexposedAttr]          = v_ignore
    table[CXCursor_AsmLabelAttr]           = v_ignore
    table[CXCursor_MacroExpansion]         = v_MacroExpansion
    table[CXCursor_TypedefDecl]            = v_TypedefDecl
    table[CXCursor_FunctionDecl]           = v_FunctionDecl
    table[CXCursor_ParmDecl]               = v_ParmDecl
    table[CXCursor_DeclStmt]               = v_DeclStmt
    table[CXCursor_VarDecl]                = v_VarDecl
    table[CXCursor_CompoundStmt]           = v_CompoundStmt
    table[CXCursor_IfStmt]                 = v_IfStmt
    table[CXCursor_ForStmt]                = v_ForStmt
    table[CXCursor_ParenExpr]              = v_under
    table[CXCursor_BinaryOperator]         = v_BinaryOperator
    table[CXCursor_UnaryOperator]          = v_UnaryOperator
    table[CXCursor_MemberRefExpr]          = v_MemberRefExpr
    table[CXCursor_CompoundAssignOperator] = v_BinaryOperator
    table[CXCursor_UnexposedExpr]          = v_under
    table[CXCursor_CStyleCastExpr]         = v_CStyleCastExpr
    table[CXCursor_DeclRefExpr]            = v_DeclRefExpr
    table[CXCursor_TypeRef]                = v_TypeRef
    table[CXCursor_IntegerLiteral]         = v_IntegerLiteral
    table[CXCursor_CharacterLiteral]       = v_CharacterLiteral
    table[CXCursor_StringLiteral]          = v_StringLiteral
    table[CXCursor_ReturnStmt]             = v_ReturnStmt
    table[CXCursor_CallExpr]               = v_CallExpr
    table[CXCursor_StructDecl]             = v_StructDecl
    table[CXCursor_UnionDecl]              = v_UnionDecl
    table[CXCursor_FieldDecl]              = v_FieldDecl
}

proc clangASTNodePrint(cursor : CXCursor, translator : c2bJou*) {
    if not PRINT_AST return
    name_str := ClangWrapper.getCursorName(cursor)
    kind_cxstr := clang.getCursorKindSpelling(cursor.kind)
    kind_str := clang.getCString(kind_cxstr)

    for i := 0; i < translator.indent; i += 1
        printf("  ")
    print "%: '%'", kind_str, name_str
}

proc v_unimplemented(cursor      : CXCursor,
                     parent      : CXCursor,
                     client_data : CXClientData*) : u32 {

    buff : char[1024]
    kind_cxstr := clang.getCursorKindSpelling(cursor.kind)
    kind_str := clang.getCString(kind_cxstr)

    ctx := getCursorContext(cursor)
    
    buff.sprintf("c2bjou: missing visitor for CXCursor kind %d -- %s", cursor.kind, kind_str)

    bjou_error(ctx, buff)

    return CXVisit_Break
}

proc v_ignore(cursor      : CXCursor,
              parent      : CXCursor,
              client_data : CXClientData*) : u32 {

    return CXVisit_Continue
}

proc v_MacroExpansion(cursor      : CXCursor,
                      parent      : CXCursor,
                      client_data : CXClientData*) : u32 {

    name := ClangWrapper.getCursorName(cursor)
    if strcmp(name, "BJOU_CT") == 0 {
        translator := client_data as c2bJou*

        tokens := translator.cw.getCursorTokens(cursor)

        if |tokens| < 4
            \die{ "c2bjou: BJOU_CT macro expansion missing directive name" }

        directive := clang.getCString(clang.getTokenSpelling(translator.cw.tu, tokens[2]))
        args      := [...ASTNode*]

        if |tokens| > 4 {
            arg_tokens := [tokens, 4:(|tokens| - 5)] # skip first 4 and last token -- BJOU_CT(MACRONAME, {we want these})
            foreach t in arg_tokens {
                str := clang.getCString(clang.getTokenSpelling(translator.cw.tu, t))     
                args.push(bjou_createStringLiteral(str))
            }
        }

        translator.created.push(bjou_createMacroUse(directive, args.data(), |args|))
    }

    return CXVisit_Continue
}

proc v_TypedefDecl(cursor      : CXCursor,
                   parent      : CXCursor,
                   client_data : CXClientData*) : u32 {

    translator := client_data as c2bJou*

    name := ClangWrapper.getCursorName(cursor)
    decl := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    # foreach child in children
    #     dispatch(child, cursor, client_data)

    translator.indent -= 1

    cx_t := clang.getCanonicalType(clang.getCursorType(cursor))

    if cx_t.kind == CXType_Record
    and |children| == 1
    and (children[0].kind == CXCursor_StructDecl
      or children[0].kind == CXCursor_UnionDecl) {
        rec := translator.created.back()
        rec_name := bjou_getStructName(rec)
        decl = bjou_createDeclarator(
                    bjou_createIdentifier(rec_name),
                    (_nullptr() as ASTNode*),
                    (_nullptr() as char**), 0)
        bjou_setContext(decl, getCursorContext(cursor))
        delete rec_name
    } else {
        decl = tyToDecl(@translator, &cx_t, cursor)
    }

    # create result
    a := bjou_createAlias(name, decl)

    translator.created.push(a)

    return CXVisit_Continue
}

proc v_CompoundStmt(cursor      : CXCursor,
                    parent      : CXCursor,
                    client_data : CXClientData*) : u32 {
    return CXVisit_Continue
}

proc v_FunctionDecl(cursor      : CXCursor,
                    parent      : CXCursor,
                    client_data : CXClientData*) : u32 {

    translator := client_data as c2bJou*

    name       := ClangWrapper.getCursorName(cursor)
    params     := [...ASTNode*]
    isVararg   := clang.Cursor_isVariadic(cursor) == 1
    retDecl    := (_nullptr() as ASTNode*)
    statements := [...ASTNode*]

    cx_t := clang.getResultType(clang.getCursorType(cursor))
    retDecl = tyToDecl(@translator, &cx_t, cursor)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    n_params := clang.Cursor_getNumArguments(cursor)

    c := 0
    n := 0
    while n < n_params {
        if children[c].kind == CXCursor_ParmDecl {
            dispatch(children[c], cursor, client_data)
            params.push(translator.created.back())
            translator.created.pop()
            n += 1
        }
        c += 1
    }

    if clang.isCursorDefinition(cursor) == 1 {
        for ; c < |children|; c += 1 {
            dispatch(children[c], cursor, client_data)
            statements.push(translator.created.back())
            translator.created.pop()    
        }

        translator.indent -= 1

        # create result
        p := bjou_createProcedure(
                 name,
                 params.data(), |params|,
                 isVararg,
                 retDecl,
                 statements.data(), |statements|)

        translator.created.push(p)
    } else {
        translator.indent -= 1

        foreach param in params
            param.bjou_setVarDeclName(bjou_makeUID("param"))        

        p := bjou_createExternProcedure(
                 name, params.data(), |params|,
                 isVararg,
                 retDecl)

        translator.created.push(p)
    }

    return CXVisit_Continue
}

proc v_ParmDecl(cursor      : CXCursor,
                parent      : CXCursor,
                client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    name           := ClangWrapper.getCursorName(cursor)
    typeDeclarator := (_nullptr() as ASTNode*)
    initialization := (_nullptr() as ASTNode*)

    # visit children
    # translator.indent += 1

    # # children := [...CXCursor]
    # translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    # # if |children| != 0 {
        # bjou_error(getCursorContext(cursor), "why does a param decl have children?")
    # }

    # # translator.indent -= 1
   
    cx_t := clang.getCursorType(cursor)
    typeDeclarator = tyToDecl(@translator, &cx_t, cursor)

    p := bjou_createParamDeclaration(
            name,
            typeDeclarator,
            initialization)

    translator.created.push(p)

    return CXVisit_Continue  
}

proc v_DeclStmt(cursor      : CXCursor,
                parent      : CXCursor,
                client_data : CXClientData*) : u32 {

    translator := client_data as c2bJou*

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    dispatch(children[0], cursor, client_data) 

    translator.indent -= 1
   
    # create result
    # this what we are doing, but we get the same result if we do nothing

    # d := translator.created.back()
    # translator.created.pop()
    # translator.created.push(d)

    return CXVisit_Continue  
}

proc v_VarDecl(cursor      : CXCursor,
               parent      : CXCursor,
               client_data : CXClientData*) : u32 {
   
    translator := client_data as c2bJou*

    name           := ClangWrapper.getCursorName(cursor)
    typeDeclarator := (_nullptr() as ASTNode*)
    initialization := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    foreach child in children if child.kind != CXCursor_TypeRef {
        dispatch(child, cursor, client_data)
        initialization = translator.created.back()
        translator.created.pop()
    }

    translator.indent -= 1
   
    cx_t := clang.getCursorType(cursor)
    typeDeclarator = tyToDecl(@translator, &cx_t, cursor)

    v := bjou_createVariableDeclaration(
            name,
            typeDeclarator,
            initialization)

    translator.created.push(v)

    return CXVisit_Continue  
}

proc v_IfStmt(cursor      : CXCursor,
              parent      : CXCursor,
              client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    conditional := (_nullptr() as ASTNode*)
    statements  := [...ASTNode*]
    _else       := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    c := 0

    dispatch(children[c], cursor, client_data) #conditional
    conditional = translator.created.back()
    translator.created.pop()

    last_end := clang.getRangeEnd(clang.getCursorExtent(children[c]))

    c += 1

    for ; c < |children|; c += 1 {        
        c_beg := clang.getRangeStart(clang.getCursorExtent(children[c]))

        rng := clang.getRange(last_end, c_beg)

        _tokens := (_nullptr() as CXToken*)
        n_tokens : u32 = 0

        clang.tokenize(translator.cw.tu, rng, &_tokens, &n_tokens)

        tokens := [_tokens, 0:n_tokens]

        hasElse := false

        foreach t in tokens {
            cxs := clang.getTokenSpelling(translator.cw.tu, t)
            spl := clang.getCString(cxs)
            if strcmp(spl, "else") == 0 {
                hasElse = true
                break
            }
        }

        if hasElse {
            _else = handleElse(@translator, cursor, [children, c:(|children| - c)])
            break     
        } else {
            dispatch(children[c], cursor, client_data)
            statements.push(translator.created.back())
            translator.created.pop()

            last_end = c_beg
        }
    }

    translator.indent -= 1
   
    # create result
    i := bjou_createIf(
            conditional,
            statements.data(), |statements|,
            _else)

    translator.created.push(i)

    return CXVisit_Continue  
}

proc handleElse(translator : c2bJou ref,
                cursor     : CXCursor,
                children   : CXCursor[])
                : ASTNode* {
   
    statements := [...ASTNode*]

    foreach child in children {
        dispatch(child, cursor, (&translator) as CXClientData*)
        statements.push(translator.created.back())
        translator.created.pop()
    }

    return bjou_createElse(statements.data(), |statements|)
}

proc v_ForStmt(cursor      : CXCursor,
               parent      : CXCursor,
               client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    initializations := [...ASTNode*]
    conditional     := (_nullptr() as ASTNode*)
    afterthoughts   := [...ASTNode*]
    statements      := [...ASTNode*]

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    last_end := clang.getRangeStart(clang.getCursorExtent(cursor))

    c := 0

    section := 0

    for ; c < |children|; c += 1 {        
        c_beg := clang.getRangeStart(clang.getCursorExtent(children[c]))

        rng := clang.getRange(last_end, c_beg)

        _tokens := (_nullptr() as CXToken*)
        n_tokens : u32 = 0

        clang.tokenize(translator.cw.tu, rng, &_tokens, &n_tokens)

        tokens := [_tokens, 0:n_tokens]

        foreach t in tokens {
            cxs := clang.getTokenSpelling(translator.cw.tu, t)
            spl := clang.getCString(cxs)
            if strcmp(spl, ";") == 0
                section += 1
        }

        dispatch(children[c], cursor, client_data)

        if section == 0      # initializations
            initializations.push(translator.created.back())
        else if section == 1 # conditional
            conditional = translator.created.back()
        else if section == 2 # afterthoughts
            afterthoughts.push(translator.created.back())
        else if section == 3 # statements
            statements.push(translator.created.back())
       
        translator.created.pop()

        last_end = c_beg
    }

    translator.indent -= 1
   
    # create result
    f := bjou_createFor(
            initializations.data(), |initializations|,
            conditional,
            afterthoughts.data(), |afterthoughts|,
            statements.data(), |statements|)

    translator.created.push(f)

    return CXVisit_Continue  
}

proc getBinOp(translator : c2bJou ref,
              cursor     : CXCursor,
              l          : CXCursor,
              r          : CXCursor)
              : char* {

    range_l := clang.getCursorExtent(l)
    range_r := clang.getCursorExtent(r)

    l_end := clang.getRangeEnd(range_l)
    r_beg := clang.getRangeStart(range_r)

    range := clang.getRange(l_end, r_beg)

    tokens := (_nullptr() as CXToken*)
    n_tokens : u32 = 0

    clang.tokenize(translator.cw.tu, range, &tokens, &n_tokens)

    cxs := clang.getTokenSpelling(translator.cw.tu, tokens[0])
    spl := clang.getCString(cxs)

    return spl
}

proc getUnOp(translator : c2bJou ref,
             cursor     : CXCursor,
             child      : CXCursor)
             : char* {

    range   := clang.getCursorExtent(cursor)
    range_c := clang.getCursorExtent(child)
    beg     := clang.getRangeStart(range)
    end     := clang.getRangeEnd(range)
    c_beg   := clang.getRangeStart(range_c)
    c_end   := clang.getRangeEnd(range_c)

    if clang.equalLocations(beg, c_beg) != 1 # prefix
        range = clang.getRange(beg, c_beg)
    else # postfix
        range = clang.getRange(c_end, end)

    tokens := (_nullptr() as CXToken*)
    n_tokens : u32 = 0

    clang.tokenize(translator.cw.tu, range, &tokens, &n_tokens)

    cxs := clang.getTokenSpelling(translator.cw.tu, tokens[0])
    spl := clang.getCString(cxs)

    return spl
}

proc v_BinaryOperator(cursor      : CXCursor,
                      parent      : CXCursor,
                      client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    left  := (_nullptr() as ASTNode*)
    right := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    dispatch(children[0], cursor, client_data) # left 
    left = translator.created.back()
    translator.created.pop()

    dispatch(children[1], cursor, client_data) # right
    right = translator.created.back()
    translator.created.pop()

    translator.indent -= 1
   
    # create result
    
    op := getBinOp(@translator, cursor, children[0], children[1])

    e := (_nullptr() as ASTNode*)

    if strcmp(op, "+") == 0
        e = bjou_createAddExpression(left, right)
    else if strcmp(op, "-") == 0
        e = bjou_createSubExpression(left, right)
    else if strcmp(op, "*") == 0
        e = bjou_createMultExpression(left, right)
    else if strcmp(op, "/") == 0
        e = bjou_createDivExpression(left, right)
    else if strcmp(op, "%") == 0
        e = bjou_createModExpression(left, right)
    else if strcmp(op, "=") == 0
        e = bjou_createAssignmentExpression(left, right)
    else if strcmp(op, "+=") == 0
        e = bjou_createAddAssignExpression(left, right)
    else if strcmp(op, "-=") == 0
        e = bjou_createSubAssignExpression(left, right)
    else if strcmp(op, "*=") == 0
        e = bjou_createMultAssignExpression(left, right)
    else if strcmp(op, "/=") == 0
        e = bjou_createDivAssignExpression(left, right)
    else if strcmp(op, "%=") == 0
        e = bjou_createModAssignExpression(left, right)
    else if strcmp(op, "<") == 0
        e = bjou_createLssExpression(left, right)
    else if strcmp(op, "<=") == 0
        e = bjou_createLeqExpression(left, right)
    else if strcmp(op, ">") == 0
        e = bjou_createGtrExpression(left, right)
    else if strcmp(op, ">=") == 0
        e = bjou_createGeqExpression(left, right)
    else if strcmp(op, "==") == 0
        e = bjou_createEquExpression(left, right)
    else if strcmp(op, "!=") == 0
        e = bjou_createNeqExpression(left, right)
    else if strcmp(op, "&&") == 0
        e = bjou_createLogAndExpression(left, right)
    else if strcmp(op, "||") == 0
        e = bjou_createLogOrExpression(left, right)
    else if strcmp(op, "[]") == 0
        e = bjou_createSubscriptExpression(left, right)
    else if strcmp(op, ".") == 0
        e = bjou_createAccessExpression(left, right)
    else \die{ "c2bjou: unrecognized operator" }

    translator.created.push(e)
    return CXVisit_Continue  
}

proc v_UnaryOperator(cursor      : CXCursor,
                     parent      : CXCursor,
                     client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    expr := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    dispatch(children[0], cursor, client_data)
    expr = translator.created.back()
    translator.created.pop()

    translator.indent -= 1
   
    # create result
    
    op := getUnOp(@translator, cursor, children[0])

    e := (_nullptr() as ASTNode*)

    if strcmp(op, "++") == 0
        e = bjou_createAddAssignExpression(expr, bjou_createIntegerLiteral("1"))
    else if strcmp(op, "--") == 0
        e = bjou_createSubAssignExpression(expr, bjou_createIntegerLiteral("1"))
    else if strcmp(op, "*") == 0
        e = bjou_createDerefExpression(expr)
    else \die{ "c2bjou: unrecognized operator" }

    translator.created.push(e)
    return CXVisit_Continue  
}

proc v_MemberRefExpr(cursor      : CXCursor,
                     parent      : CXCursor,
                     client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    member_name := clang.getCString(clang.getCursorSpelling(cursor))

    left  := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    dispatch(children[0], cursor, client_data)
    left = translator.created.back()
    translator.created.pop()
    
    translator.indent -= 1
   
    # create result
    
    a := bjou_createAccessExpression(left, bjou_createIdentifier(member_name))

    translator.created.push(a)

    return CXVisit_Continue  
}

proc v_CallExpr(cursor      : CXCursor,
                parent      : CXCursor,
                client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    left  := (_nullptr() as ASTNode*)
    _args := [...ASTNode*]
    args  := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    dispatch(children[0], cursor, client_data) # left 
    left = translator.created.back()
    translator.created.pop()

    arg_children := [children, 1:(|children| - 1)]

    foreach child in arg_children {
        dispatch(child, cursor, client_data)
        _args.push(translator.created.back())
        translator.created.pop()
    }

    args = bjou_createArgList(_args.data(), |_args|)

    translator.indent -= 1
   
    # create result
    c := bjou_createCallExpression(left, args)

    translator.created.push(c)

    return CXVisit_Continue  
}

proc v_under(cursor      : CXCursor,
             parent      : CXCursor,
             client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    dispatch(children[0], cursor, client_data) 

    translator.indent -= 1
   
    # create result
    u := translator.created.back()
    translator.created.pop()

    translator.created.push(u)

    return CXVisit_Continue  
}

proc v_DeclRefExpr(cursor      : CXCursor,
                   parent      : CXCursor,
                   client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    spl := ClangWrapper.getCursorName(cursor)

    # create result
    i := bjou_createIdentifier(spl)

    translator.created.push(i)

    return CXVisit_Continue  
}

proc v_TypeRef(cursor      : CXCursor,
               parent      : CXCursor,
               client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    cx_t := clang.getCursorType(cursor)
    spl  := clang.getCString(clang.getTypeSpelling(cx_t))

    # create result
    i := bjou_createIdentifier(spl)

    translator.created.push(i)

    return CXVisit_Continue  
}

proc v_CStyleCastExpr(cursor      : CXCursor,
                      parent      : CXCursor,
                      client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    expr  := (_nullptr() as ASTNode*)
    ident := (_nullptr() as ASTNode*)
    decl  := (_nullptr() as ASTNode*)

    # visit children
    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    if strcmp(ClangWrapper.getCursorName(children[0]), "bjou_ct_t") == 0 {
        unex := children[1]
        unex_ch := [...CXCursor]
        translator.cw.traverse(unex, child_collector, (&unex_ch) as CXClientData*)
        code := ClangWrapper.getCursorName(unex_ch[0])
        code += 1
        code[strlen(code) - 1] = '\0'

        code' := [...char]
        for i := 0; i < strlen(code); i += 1 {
            if code[i] == '\\'
                i += 1
            code'.push(code[i])
        }
        code'.push('\0')

        multi := bjou_parseToMultiNode(code'.data())
        translator.created.push(multi)
    } else {
        translator.indent += 1

        dispatch(children[0], cursor, client_data)
        expr = translator.created.back()
        translator.created.pop()
    
        translator.indent -= 1

        t := clang.getCursorType(cursor)

        # create result
        decl = tyToDecl(@translator, &t, cursor)

        a := bjou_createAsExpression(expr, decl)

        translator.created.push(a)
    }

    return CXVisit_Continue  
}

proc v_IntegerLiteral(cursor      : CXCursor,
                      parent      : CXCursor,
                      client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    # Use eval instead of tokens so that integer literals
    # that came from macro instantiations work.
    val := clang.EvalResult_getAsLongLong(clang.Cursor_Evaluate(cursor))

    buff : char[32]
    sprintf(buff, "%lld", val)

    # create result
    i := bjou_createIntegerLiteral(buff)

    translator.created.push(i)

    return CXVisit_Continue  
}

proc v_CharacterLiteral(cursor      : CXCursor,
                        parent      : CXCursor,
                        client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    tokens := translator.cw.getCursorTokens(cursor)
    cxs := clang.getTokenSpelling(translator.cw.tu, tokens[0])
    spl := clang.getCString(cxs)

    # create result
    c := bjou_createCharLiteral(spl)

    translator.created.push(c)

    return CXVisit_Continue  
}

proc v_StringLiteral(cursor      : CXCursor,
                     parent      : CXCursor,
                     client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    spl := ClangWrapper.getCursorName(cursor)
    spl += 1
    spl[strlen(spl) - 1] = '\0'

    # create result
    s := bjou_createStringLiteral(spl)

    translator.created.push(s)

    return CXVisit_Continue  
}

proc v_ReturnStmt(cursor      : CXCursor,
                  parent      : CXCursor,
                  client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    expr := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    if |children| > 0 {
        dispatch(children[0], cursor, client_data) 
        expr = translator.created.back()
        translator.created.pop()
    }

    translator.indent -= 1
   
    # create result

    r := bjou_createReturn(expr)

    translator.created.push(r)

    return CXVisit_Continue  
}

proc v_StructDecl(cursor      : CXCursor,
                  parent      : CXCursor,
                  client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    memberVarDecls := [...ASTNode*] 

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    foreach child in children {
        dispatch(child, cursor, client_data)
        memberVarDecls.push(translator.created.back())
        translator.created.pop()
    }

    translator.indent -= 1
   
    # create result

    name := clang.getCString(clang.getCursorSpelling(cursor))
    if strlen(name) == 0
        name = bjou_makeUID("C_struct")
   
    s := bjou_createStruct(
            name,
            (_nullptr() as ASTNode*),
            memberVarDecls.data(), |memberVarDecls|,
            (_nullptr() as ASTNode**), 0,
            (_nullptr() as ASTNode**), 0,
            (_nullptr() as ASTNode**), 0,
            (_nullptr() as ASTNode**), 0)

    delete name

    translator.created.push(s)
    translator.structs.push(s)

    return CXVisit_Continue  
}

proc v_UnionDecl(cursor      : CXCursor,
                 parent      : CXCursor,
                 client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    cx_t := clang.getCursorType(cursor)
    size := clang.Type_getSizeOf(cx_t)

    decl  := bjou_createDeclarator(
            bjou_createIdentifier("u8"),
            (_nullptr() as ASTNode*),
            (_nullptr() as char**), 0)

    buff : char[32]
    sprintf(buff, "%d", size)
    decl = bjou_createArrayDeclarator(decl, bjou_createIntegerLiteral(buff))

    bytes := bjou_createVariableDeclaration("__bytes", decl, (_nullptr() as ASTNode*))

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    foreach child in children {
        dispatch(child, cursor, client_data)
    }

    translator.indent -= 1
   
    # create result
    name := clang.getCString(clang.getCursorSpelling(cursor))
    if strlen(name) == 0
        name = bjou_makeUID("C_union")

    s := bjou_createStruct(
            name,
            (_nullptr() as ASTNode*),
            &bytes, 1,
            (_nullptr() as ASTNode**), 0,
            (_nullptr() as ASTNode**), 0,
            (_nullptr() as ASTNode**), 0,
            (_nullptr() as ASTNode**), 0)
    delete name

    translator.created.push(s)
    translator.structs.push(s)

    return CXVisit_Continue  
}

proc v_FieldDecl(cursor      : CXCursor,
                 parent      : CXCursor,
                 client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    name := ClangWrapper.getCursorName(cursor)
    cx_t := clang.getCanonicalType(clang.getCursorType(cursor))
    decl := tyToDecl(@translator, &cx_t, cursor)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    # foreach child in children {
    #     dispatch(child, cursor, client_data) 
    # }

    translator.indent -= 1
   
    # create result
    v := bjou_createFieldDeclaration(name, decl, (_nullptr() as ASTNode*))

    translator.created.push(v)

    return CXVisit_Continue  
}


proc tyToDecl(translator : c2bJou ref, t : CXType*, cursor : CXCursor) : ASTNode* {
    # if translator.types.find(t).isnull()
    #     translator.types.insert(t, makeDeclFromTy(translator, t))
    # return bjou_clone(translator.types[t])
    return makeDeclFromTy(translator, t, cursor)
}

proc declFromName(name : char*) : ASTNode* {
    id := bjou_createIdentifier(name)
    return bjou_createDeclarator(
                id,
                (_nullptr() as ASTNode*),
                (_nullptr() as char**), 0)
}

proc makeDeclFromTy(translator : c2bJou ref, t : CXType*, cursor : CXCursor) : ASTNode* {
    decl := (_nullptr() as ASTNode*)

    if        t.kind == CXType_Void {
        decl = declFromName("void")
    } else if t.kind == CXType_Bool {
        decl = declFromName("bool")
    } else if t.kind == CXType_Char_U
      or      t.kind == CXType_UChar {
        decl = declFromName("u8")
    } else if t.kind == CXType_UShort {
        decl = declFromName("u16")
    } else if t.kind == CXType_UInt {
        decl = declFromName("u32")
    } else if t.kind == CXType_ULong or t.kind == CXType_ULongLong {
        decl = declFromName("u64")
    } else if t.kind == CXType_Char_S
      or      t.kind == CXType_SChar {
        decl = declFromName("char")
    } else if t.kind == CXType_Short {
        decl = declFromName("i16")
    } else if t.kind == CXType_Int {
        decl = declFromName("i32")
    } else if t.kind == CXType_Long or t.kind == CXType_LongLong {
        decl = declFromName("i64")
    } else if t.kind == CXType_Float {
        decl = declFromName("f32")
    } else if t.kind == CXType_Double {
        decl = declFromName("f64")
    } else if t.kind == CXType_Record
           or t.kind == CXType_Elaborated {
        name := clang.getCString(clang.getTypeSpelling(@t))
        str  := "struct "
        if strlen(name) > strlen(str) {
            i := 0
            for ; i < strlen(str); i += 1 {
                if str[i] != name[i]
                    break
            }
            if i == strlen(str)
                name += i 
        }
        decl = declFromName(name)
    } else if t.kind == CXType_ConstantArray {
        elem_t := clang.getElementType(@t)
        elem_decl := makeDeclFromTy(translator, &elem_t, cursor)
        size := clang.getNumElements(@t)
        buff : char[32]
        sprintf(buff, "%d", size)
        decl = bjou_createArrayDeclarator(elem_decl, bjou_createIntegerLiteral(buff))
    } else if t.kind == CXType_Pointer {
        elem_t := clang.getPointeeType(@t)
        decl = bjou_createPointerDeclarator(makeDeclFromTy(translator, &elem_t, cursor))
    } else if t.kind == CXType_IncompleteArray {
        elem_t := clang.getElementType(@t)
        elem_decl := makeDeclFromTy(translator, &elem_t, cursor)
        decl = bjou_createPointerDeclarator(elem_decl)
    } else if t.kind == CXType_FunctionProto
           or (t.kind == CXType_Unexposed and clang.getNumArgTypes(@t) != -1) {
        paramDecls := [...ASTNode*]

        isVararg := clang.isFunctionTypeVariadic(@t) == 1   
        n_argTypes := clang.getNumArgTypes(@t)

        for p := 0; p < n_argTypes; p += 1 {
            param_t := clang.getArgType(@t, p)
            paramDecls.push(makeDeclFromTy(translator, &param_t, cursor))
        }

        ret_t := clang.getResultType(@t)
        retDecl := makeDeclFromTy(translator, &ret_t, cursor)
       
        decl = bjou_createProcedureDeclarator(paramDecls.data(), |paramDecls|, retDecl, isVararg)
    } else if t.kind == CXType_Typedef {
        canon := clang.getCanonicalType(@t)
        decl = makeDeclFromTy(translator, &canon, cursor)
    } else {
        print "bad type: %", t.kind
        \die{ "c2bjou: unable to translate type" }
    }

    bjou_setContext(decl, getCursorContext(cursor))

    return decl
}
