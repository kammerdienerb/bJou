# visitors.bjou

module c2bjou_visitors

import "clang.bjou"
import "compiler.bjou"

import "dltr.bjou"

type visitor_t = <(CXCursor,      # cursor
                   CXCursor,      # parent
                   CXClientData*) # client_data
                   : u32>

proc child_collector(cursor      : CXCursor,
                     parent      : CXCursor,
                     client_data : CXClientData*) : u32 {

    children := getref(@(client_data as CXCursor[...]*))
    translator := client_data as c2bJou*

    if cursor.kind == CXCursor_CompoundStmt
        translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)   
    else
        children.push(cursor)   

    return CXVisit_Continue
}

proc getCursorContext(cursor : CXCursor) : Context * {
    rng := clang.getCursorExtent(cursor)

    cxf  := (_nullptr() as CXFile*)
    line : u32 = 0
    col  : u32 = 0
    off  : u32 = 0

    _beg := clang.getRangeStart(rng)
    clang.getSpellingLocation(_beg, &cxf, &line, &col, &off)
    beg := { Loc: .line = line, .character = col }
    
    _end := clang.getRangeStart(rng)
    clang.getSpellingLocation(_end, &cxf, &line, &col, &off)
    end := { Loc: .line = line, .character = col + 1 }

    fname := clang.getCString(clang.getFileName(cxf))

    return bjou_createContext(&beg, &end, fname)   
}

proc dispatch(cursor      : CXCursor,
              parent      : CXCursor,
              client_data : CXClientData*) : u32 {

    translator := client_data as c2bJou*

    cursor.clangASTNodePrint(translator)

    visitor := translator.visitor_table[cursor.kind]

    size_before := |translator.created|
    visitor(cursor, parent, client_data)
    size_after := |translator.created|

    if size_after > size_before {
        node := translator.created.back()
        ctx  := getCursorContext(cursor)

        bjou_setContext(node, ctx)

        if cursor.kind == CXCursor_FunctionDecl
            bjou_setProcNameContext(node, ctx)

        else if cursor.kind == CXCursor_VarDecl
        or      cursor.kind == CXCursor_FieldDecl
        or      cursor.kind == CXCursor_ParmDecl
            bjou_setVarDeclNameContext(node, ctx)

        else if cursor.kind == CXCursor_StructDecl
        or      cursor.kind == CXCursor_UnionDecl
            bjou_setStructNameContext(node, ctx)

        else if cursor.kind == CXCursor_TypedefDecl
            bjou_setAliasNameContext(node, ctx)

        bjou_freeContext(ctx)
    }

    return CXVisit_Continue
}

proc init_visitor_table(table : visitor_t[CXCursor_END_]) {
    table.fill(|table|, v_unimplemented)

    table[CXCursor_MacroDefinition]        = v_ignore
    table[CXCursor_InclusionDirective]     = v_ignore
    table[CXCursor_UnexposedAttr]          = v_ignore
    table[CXCursor_AsmLabelAttr]           = v_ignore
    table[CXCursor_MacroExpansion]         = v_MacroExpansion
    table[CXCursor_TypedefDecl]            = v_TypedefDecl
    table[CXCursor_FunctionDecl]           = v_FunctionDecl
    table[CXCursor_ParmDecl]               = v_ParmDecl
    table[CXCursor_DeclStmt]               = v_DeclStmt
    table[CXCursor_VarDecl]                = v_VarDecl
    table[CXCursor_CompoundStmt]           = v_CompoundStmt
    table[CXCursor_IfStmt]                 = v_IfStmt
    table[CXCursor_ForStmt]                = v_ForStmt
    table[CXCursor_ParenExpr]              = v_under
    table[CXCursor_BinaryOperator]         = v_BinaryOperator
    table[CXCursor_UnaryOperator]          = v_UnaryOperator
    table[CXCursor_MemberRefExpr]          = v_MemberRefExpr
    table[CXCursor_ArraySubscriptExpr]     = v_ArraySubscriptExpr
    table[CXCursor_CompoundAssignOperator] = v_BinaryOperator
    table[CXCursor_ConditionalOperator]    = v_ConditionalOperator
    table[CXCursor_UnexposedExpr]          = v_under
    table[CXCursor_CStyleCastExpr]         = v_CStyleCastExpr
    table[CXCursor_DeclRefExpr]            = v_DeclRefExpr
    table[CXCursor_TypeRef]                = v_TypeRef
    table[CXCursor_IntegerLiteral]         = v_IntegerLiteral
    table[CXCursor_FloatingLiteral]        = v_FloatingLiteral
    table[CXCursor_CharacterLiteral]       = v_CharacterLiteral
    table[CXCursor_StringLiteral]          = v_StringLiteral
    table[CXCursor_ReturnStmt]             = v_ReturnStmt
    table[CXCursor_CallExpr]               = v_CallExpr
    table[CXCursor_StructDecl]             = v_StructDecl
    table[CXCursor_UnionDecl]              = v_UnionDecl
    table[CXCursor_EnumDecl]               = v_EnumDecl
    table[CXCursor_FieldDecl]              = v_FieldDecl
}

proc clangASTNodePrint(cursor : CXCursor, translator : c2bJou*) {
    if not PRINT_AST return
    name_str := ClangWrapper.getCursorName(cursor)
    if strlen(name_str) == 0
        name_str = clang.getCString(clang.getCursorSpelling(cursor))
    kind_cxstr := clang.getCursorKindSpelling(cursor.kind)
    kind_str := clang.getCString(kind_cxstr)

    for i := 0; i < translator.indent; i += 1
        printf("  ")
    print "%: '%'", kind_str, name_str
}

proc v_unimplemented(cursor      : CXCursor,
                     parent      : CXCursor,
                     client_data : CXClientData*) : u32 {

    buff : char[1024]
    kind_cxstr := clang.getCursorKindSpelling(cursor.kind)
    kind_str := clang.getCString(kind_cxstr)

    ctx := getCursorContext(cursor)
    
    buff.sprintf("c2bjou: missing visitor for CXCursor kind %d -- %s", cursor.kind, kind_str)

    translator := client_data as c2bJou*

    bjou_error(ctx, buff)

    return CXVisit_Break
}

proc v_ignore(cursor      : CXCursor,
              parent      : CXCursor,
              client_data : CXClientData*) : u32 {

    return CXVisit_Continue
}

proc v_MacroExpansion(cursor      : CXCursor,
                      parent      : CXCursor,
                      client_data : CXClientData*) : u32 {

    name := ClangWrapper.getCursorName(cursor)
    if strcmp(name, "BJOU_CT") == 0 {
        translator := client_data as c2bJou*

        tokens := translator.cw.getCursorTokens(cursor)

        if |tokens| < 4
            \die{ "c2bjou: BJOU_CT macro expansion missing directive name" }

        directive := clang.getCString(clang.getTokenSpelling(translator.cw.tu, tokens[2]))
        args      := [...ASTNode*]

        if |tokens| > 4 {
            arg_tokens := [tokens, 4:(|tokens| - 5)] # skip first 4 and last token -- BJOU_CT(MACRONAME, {we want these})
            foreach t in arg_tokens {
                str := clang.getCString(clang.getTokenSpelling(translator.cw.tu, t))     
                args.push(bjou_createStringLiteral(str))
            }
        }

        translator.created.push(bjou_createMacroUse(directive, args.data(), |args|))
    }

    return CXVisit_Continue
}

proc v_TypedefDecl(cursor      : CXCursor,
                   parent      : CXCursor,
                   client_data : CXClientData*) : u32 {

    translator := client_data as c2bJou*

    name := ClangWrapper.getCursorName(cursor)
    decl := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    # foreach child in children
    #     dispatch(child, cursor, client_data)

    translator.indent -= 1

    cx_t := clang.getCanonicalType(clang.getCursorType(cursor))

    if cx_t.kind == CXType_Record
    and |children| == 1
    and (children[0].kind == CXCursor_StructDecl
      or children[0].kind == CXCursor_UnionDecl
      or children[0].kind == CXCursor_EnumDecl) {
        rec := translator.created.back()

        rec_name := <<
            if children[0].kind == CXCursor_EnumDecl
                <-bjou_getEnumName(rec)
            else
                <-bjou_getStructName(rec)
        >>

        decl = bjou_createDeclarator(
                    bjou_createIdentifier(rec_name),
                    (_nullptr() as ASTNode*),
                    (_nullptr() as char**), 0)
        bjou_setContext(decl, getCursorContext(cursor))
        delete rec_name
    } else {
        decl = tyToDecl(@translator, &cx_t, cursor)
    }

    # create result
    a := bjou_createAlias(name, decl)

    translator.created.push(a)

    return CXVisit_Continue
}

proc v_CompoundStmt(cursor      : CXCursor,
                    parent      : CXCursor,
                    client_data : CXClientData*) : u32 {
    return CXVisit_Continue
}

proc cursorIsStatement(cursor : CXCursor) : bool {
    return  cursor.kind > CXCursor_FirstStmt
        and cursor.kind < CXCursor_LastStmt
}

proc cursorIsExpression(cursor : CXCursor) : bool {
    return  cursor.kind > CXCursor_FirstExpr
        and cursor.kind < CXCursor_LastExpr
}

proc v_FunctionDecl(cursor      : CXCursor,
                    parent      : CXCursor,
                    client_data : CXClientData*) : u32 {

    translator := client_data as c2bJou*

    # someone decided it was a good idea to add overloading to C...
    # so we have to get the mangled name for our bJou decls
    name          := nullptr$char()
    _name         := ClangWrapper.getCursorName(cursor)
    _mangled_name := clang.getCString(clang.Cursor_getMangling(cursor))

    if _mangled_name.c_str_startswith("__Z")
        name = _mangled_name + 1
    else
        name = _name

    p          := (_nullptr() as ASTNode*)
    params     := [...ASTNode*]
    isVararg   := clang.Cursor_isVariadic(cursor) == 1
    retDecl    := (_nullptr() as ASTNode*)
    statements := [...ASTNode*]

    cx_t := clang.getResultType(clang.getCursorType(cursor))
    retDecl = tyToDecl(@translator, &cx_t, cursor)

    if  clangextras.isFunctionInline(cursor)
    and clang.isCursorDefinition(cursor) == 0 {
        delete _mangled_name
        delete _name
        return CXVisit_Continue
    }

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    n_params := clang.Cursor_getNumArguments(cursor)

    n := 0
    for ; n < n_params; n += 1 {
        parm := clang.Cursor_getArgument(cursor, n)
        dispatch(parm, cursor, client_data)
        params.push(translator.created.back())
        translator.created.pop()
    }
    
    c := 0
   
    seen_parm := false

    for ; c < |children|; c += 1 {
        if children[c].kind == CXCursor_ParmDecl
            seen_parm = true
        else if seen_parm and children[c].kind != CXCursor_ParmDecl
            break
    }

    if clang.isCursorDefinition(cursor) == 1 {
        for ; c < |children|; c += 1 {
            if cursorIsStatement(children[c])
            or cursorIsExpression(children[c]) {
                dispatch(children[c], cursor, client_data)
                statements.push(translator.created.back())
                translator.created.pop()
            }
        }

        translator.indent -= 1

        # create result
        p = bjou_createProcedure(
                 name,
                 params.data(), |params|,
                 isVararg,
                 retDecl,
                 statements.data(), |statements|)
    } else {
        translator.indent -= 1

        foreach param in params
            param.bjou_setVarDeclName(bjou_makeUID("param"))        

        p = bjou_createExternProcedure(
                 name, params.data(), |params|,
                 isVararg,
                 retDecl)
    }

    foreach decl in translator.inlineTypeDecls
        translator.created.push(decl)
    translator.inlineTypeDecls.clear()

    translator.created.push(p)

    delete _mangled_name
    delete _name

    return CXVisit_Continue
}

proc v_ParmDecl(cursor      : CXCursor,
                parent      : CXCursor,
                client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    name           := ClangWrapper.getCursorName(cursor)
    typeDeclarator := (_nullptr() as ASTNode*)
    initialization := (_nullptr() as ASTNode*)

    # visit children
    # translator.indent += 1

    # # children := [...CXCursor]
    # translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    # # if |children| != 0 {
        # bjou_error(getCursorContext(cursor), "why does a param decl have children?")
    # }

    # # translator.indent -= 1
   
    cx_t := clang.getCursorType(cursor)
    typeDeclarator = tyToDecl(@translator, &cx_t, cursor)

    p := bjou_createParamDeclaration(
            name,
            typeDeclarator,
            initialization)

    translator.created.push(p)

    return CXVisit_Continue  
}

proc v_DeclStmt(cursor      : CXCursor,
                parent      : CXCursor,
                client_data : CXClientData*) : u32 {

    translator := client_data as c2bJou*

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    foreach ref child in children {
        if child.kind == CXCursor_StructDecl
        or child.kind == CXCursor_UnionDecl {
            dispatch(child, cursor, client_data)
            rec := translator.created.back()
            translator.created.pop()
            translator.inlineTypeDecls.push(rec)
        } else if child.kind == CXCursor_VarDecl {
            dispatch(child, cursor, client_data)
        }
    }

    translator.indent -= 1
   
    return CXVisit_Continue  
}

proc v_VarDecl(cursor      : CXCursor,
               parent      : CXCursor,
               client_data : CXClientData*) : u32 {
   
    translator := client_data as c2bJou*

    name           := ClangWrapper.getCursorName(cursor)
    typeDeclarator := (_nullptr() as ASTNode*)
    initialization := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    cx_t := clang.getCursorType(cursor)
    typeDeclarator = tyToDecl(@translator, &cx_t, cursor)

    if clangextras.isVarInitialized(cursor) {
        foreach child in children if child.kind != CXCursor_TypeRef {
            dispatch(child, cursor, client_data)
            initialization = translator.created.back()
            translator.created.pop()
        }
    } else if cx_t.kind != CXType_ConstantArray {
        initialization = makeZeroInitExpr(@translator, &cx_t, cursor)
    }

    translator.indent -= 1

    v := bjou_createVariableDeclaration(
            name,
            typeDeclarator,
            initialization)

    translator.created.push(v)

    return CXVisit_Continue  
}

proc v_IfStmt(cursor      : CXCursor,
              parent      : CXCursor,
              client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    conditional := (_nullptr() as ASTNode*)
    statements  := [...ASTNode*]
    _else       := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    c := 0

    dispatch(children[c], cursor, client_data) #conditional
    conditional = translator.created.back()
    translator.created.pop()

    last_end := clang.getRangeEnd(clang.getCursorExtent(children[c]))

    c += 1

    for ; c < |children|; c += 1 {        
        c_beg := clang.getRangeStart(clang.getCursorExtent(children[c]))

        rng := clang.getRange(last_end, c_beg)

        _tokens := (_nullptr() as CXToken*)
        n_tokens : u32 = 0

        clang.tokenize(translator.cw.tu, rng, &_tokens, &n_tokens)

        tokens := [_tokens, 0:n_tokens]

        hasElse := false

        foreach t in tokens {
            cxs := clang.getTokenSpelling(translator.cw.tu, t)
            spl := clang.getCString(cxs)
            if strcmp(spl, "else") == 0 {
                hasElse = true
                break
            }
        }

        if hasElse {
            _else = handleElse(@translator, cursor, [children, c:(|children| - c)])
            break     
        } else {
            dispatch(children[c], cursor, client_data)
            statements.push(translator.created.back())
            translator.created.pop()

            last_end = c_beg
        }
    }

    translator.indent -= 1
   
    # create result
    i := bjou_createIf(
            conditional,
            statements.data(), |statements|,
            _else)

    translator.created.push(i)

    return CXVisit_Continue  
}

proc handleElse(translator : c2bJou ref,
                cursor     : CXCursor,
                children   : CXCursor[])
                : ASTNode* {
   
    statements := [...ASTNode*]

    foreach child in children {
        dispatch(child, cursor, (&translator) as CXClientData*)
        statements.push(translator.created.back())
        translator.created.pop()
    }

    return bjou_createElse(statements.data(), |statements|)
}

proc v_ForStmt(cursor      : CXCursor,
               parent      : CXCursor,
               client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    initializations := [...ASTNode*]
    conditional     := (_nullptr() as ASTNode*)
    afterthoughts   := [...ASTNode*]
    statements      := [...ASTNode*]

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    last_end := clang.getRangeStart(clang.getCursorExtent(cursor))

    c := 0

    section := 0

    for ; c < |children|; c += 1 {        
        c_beg := clang.getRangeStart(clang.getCursorExtent(children[c]))

        rng := clang.getRange(last_end, c_beg)

        _tokens := (_nullptr() as CXToken*)
        n_tokens : u32 = 0

        clang.tokenize(translator.cw.tu, rng, &_tokens, &n_tokens)

        tokens := [_tokens, 0:n_tokens]

        foreach t in tokens {
            cxs := clang.getTokenSpelling(translator.cw.tu, t)
            spl := clang.getCString(cxs)
            if strcmp(spl, ";") == 0
                section += 1
        }

        dispatch(children[c], cursor, client_data)

        if section == 0      # initializations
            initializations.push(translator.created.back())
        else if section == 1 # conditional
            conditional = translator.created.back()
        else if section == 2 # afterthoughts
            afterthoughts.push(translator.created.back())
        else if section == 3 # statements
            statements.push(translator.created.back())
       
        translator.created.pop()

        last_end = c_beg
    }

    translator.indent -= 1
   
    # create result
    f := bjou_createFor(
            initializations.data(), |initializations|,
            conditional,
            afterthoughts.data(), |afterthoughts|,
            statements.data(), |statements|)

    translator.created.push(f)

    return CXVisit_Continue  
}

proc getBinOp(translator : c2bJou ref,
              cursor     : CXCursor,
              l          : CXCursor,
              r          : CXCursor)
              : char* {

    op := clangextras.getOperatorString(cursor)

    if op.isnull()
        \die{ "could not extract binary operator" }

    return op

    # range_l := clang.getCursorExtent(l)
    # range_r := clang.getCursorExtent(r)

    # l_end := clang.getRangeEnd(range_l)
    # r_beg := clang.getRangeStart(range_r)

    # range := clang.getRange(l_end, r_beg)

    # tokens := (_nullptr() as CXToken*)
    # n_tokens : u32 = 0

    # clang.tokenize(translator.cw.tu, range, &tokens, &n_tokens)

    # if n_tokens > 0 {
    #     cxs := clang.getTokenSpelling(translator.cw.tu, tokens[0])
    #     spl := clang.getCString(cxs)
    #     return spl
    # }

    # slice := translator.cw.getCursorTokens(cursor)
    # if |slice| == 3 {
    #     cxs := clang.getTokenSpelling(translator.cw.tu, slice[1])
    #     spl := clang.getCString(cxs)
    #     return spl
    # }

    # \die{ "could not extract binary operator" }

    # return nullptr$char()
}

proc getUnOp(translator : c2bJou ref,
             cursor     : CXCursor,
             child      : CXCursor)
             : char* {

    range   := clang.getCursorExtent(cursor)
    range_c := clang.getCursorExtent(child)
    beg     := clang.getRangeStart(range)
    end     := clang.getRangeEnd(range)
    c_beg   := clang.getRangeStart(range_c)
    c_end   := clang.getRangeEnd(range_c)

    if clang.equalLocations(beg, c_beg) != 1 # prefix
        range = clang.getRange(beg, c_beg)
    else # postfix
        range = clang.getRange(c_end, end)

    tokens := (_nullptr() as CXToken*)
    n_tokens : u32 = 0

    clang.tokenize(translator.cw.tu, range, &tokens, &n_tokens)

    cxs := clang.getTokenSpelling(translator.cw.tu, tokens[0])
    spl := clang.getCString(cxs)

    return spl
}

proc v_BinaryOperator(cursor      : CXCursor,
                      parent      : CXCursor,
                      client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    left  := (_nullptr() as ASTNode*)
    right := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    dispatch(children[0], cursor, client_data) # left 
    left = translator.created.back()
    translator.created.pop()

    dispatch(children[1], cursor, client_data) # right
    right = translator.created.back()
    translator.created.pop()

    translator.indent -= 1
   
    # create result
    
    op := getBinOp(@translator, cursor, children[0], children[1])

    e := (_nullptr() as ASTNode*)

    if strcmp(op, "+") == 0
        e = bjou_createAddExpression(left, right)
    else if strcmp(op, "-") == 0
        e = bjou_createSubExpression(left, right)
    else if strcmp(op, "<<") == 0
        e = bjou_createBSHLExpression(left, right)
    else if strcmp(op, ">>") == 0
        e = bjou_createBSHRExpression(left, right)
    else if strcmp(op, "*") == 0
        e = bjou_createMultExpression(left, right)
    else if strcmp(op, "/") == 0
        e = bjou_createDivExpression(left, right)
    else if strcmp(op, "%") == 0
        e = bjou_createModExpression(left, right)
    else if strcmp(op, "=") == 0
        e = bjou_createAssignmentExpression(left, right)
    else if strcmp(op, "+=") == 0
        e = bjou_createAddAssignExpression(left, right)
    else if strcmp(op, "-=") == 0
        e = bjou_createSubAssignExpression(left, right)
    else if strcmp(op, "*=") == 0
        e = bjou_createMultAssignExpression(left, right)
    else if strcmp(op, "/=") == 0
        e = bjou_createDivAssignExpression(left, right)
    else if strcmp(op, "%=") == 0
        e = bjou_createModAssignExpression(left, right)
    else if strcmp(op, "<") == 0
        e = bjou_createLssExpression(left, right)
    else if strcmp(op, "<=") == 0
        e = bjou_createLeqExpression(left, right)
    else if strcmp(op, ">") == 0
        e = bjou_createGtrExpression(left, right)
    else if strcmp(op, ">=") == 0
        e = bjou_createGeqExpression(left, right)
    else if strcmp(op, "==") == 0
        e = bjou_createEquExpression(left, right)
    else if strcmp(op, "!=") == 0
        e = bjou_createNeqExpression(left, right)
    else if strcmp(op, "&&") == 0
        e = bjou_createLogAndExpression(left, right)
    else if strcmp(op, "||") == 0
        e = bjou_createLogAndExpression(left, right)
    else if strcmp(op, "&") == 0
        e = bjou_createBANDExpression(left, right)
    else if strcmp(op, "|") == 0
        e = bjou_createBORExpression(left, right)
    else if strcmp(op, "^") == 0
        e = bjou_createBXORExpression(left, right)
    else if strcmp(op, "[]") == 0
        e = bjou_createSubscriptExpression(left, right)
    else if strcmp(op, ".") == 0
        e = bjou_createAccessExpression(left, right)
    else \die{ "c2bjou: unrecognized operator" }

    translator.created.push(e)

    return CXVisit_Continue  
}

proc v_UnaryOperator(cursor      : CXCursor,
                     parent      : CXCursor,
                     client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    expr := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    dispatch(children[0], cursor, client_data)
    expr = translator.created.back()
    translator.created.pop()

    translator.indent -= 1
   
    # create result
    
    op := getUnOp(@translator, cursor, children[0])

    e := (_nullptr() as ASTNode*)

    if strcmp(op, "++") == 0
        e = bjou_createAddAssignExpression(expr, bjou_createIntegerLiteral("1"))
    else if strcmp(op, "--") == 0
        e = bjou_createSubAssignExpression(expr, bjou_createIntegerLiteral("1"))
    else if strcmp(op, "*") == 0
        e = bjou_createDerefExpression(expr)
    else if strcmp(op, "!") == 0
        e = bjou_createNotExpression(expr)
    else if strcmp(op, "~") == 0
        e = bjou_createBNEGExpression(expr)
    else if strcmp(op, "-") == 0 {
        e = bjou_createMultExpression(expr, bjou_createIntegerLiteral("-1")) 
    } else \die{ "c2bjou: unrecognized operator" }

    translator.created.push(e)
    return CXVisit_Continue  
}

proc v_ConditionalOperator(cursor      : CXCursor,
                           parent      : CXCursor,
                           client_data : CXClientData*) : u32 {

    translator := client_data as c2bJou*

    blk  := (_nullptr() as ASTNode*)
    _if  := (_nullptr() as ASTNode*)
    yldt := (_nullptr() as ASTNode*)
    _els := (_nullptr() as ASTNode*)
    yldf := (_nullptr() as ASTNode*)
    cond := (_nullptr() as ASTNode*)
    tru  := (_nullptr() as ASTNode*)
    fal  := (_nullptr() as ASTNode*)
    
    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    dispatch(children[0], cursor, client_data)
    cond = translator.created.back()
    translator.created.pop()
    
    dispatch(children[1], cursor, client_data)
    tru = translator.created.back()
    translator.created.pop()

    dispatch(children[2], cursor, client_data)
    fal = translator.created.back()
    translator.created.pop()

    translator.indent -= 1

    yldt = bjou_createExprBlockYield(tru)
    yldf = bjou_createExprBlockYield(fal)
    _els = bjou_createElse(&yldf, 1) 
    _if  = bjou_createIf(cond, &yldt, 1, _els)
    blk  = bjou_createExprBlock(&_if, 1)

    translator.created.push(blk)

    return CXVisit_Continue
}

proc v_MemberRefExpr(cursor      : CXCursor,
                     parent      : CXCursor,
                     client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    member_name := clang.getCString(clang.getCursorSpelling(cursor))

    left  := (_nullptr() as ASTNode*)

    cx_t := clang.getCursorType(cursor)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    dispatch(children[0], cursor, client_data)

    l_cx_t := clang.getCursorType(children[0])

    left = translator.created.back()
    translator.created.pop()
    
    translator.indent -= 1
   
    # create result
    l_cx_t = clang.getCanonicalType(l_cx_t)

    result := nullptr$ASTNode()

    if clangextras.typeIsUnion(l_cx_t) {
        decl_elems : ASTNode*[2]
        decl_elems[0] = tyToDecl(@translator, &l_cx_t, cursor)
        decl_elems[1] = tyToDecl(@translator, &cx_t, cursor)

        call := bjou_createCallExpression(
                    bjou_createIdentifierWithInst(
                        "__union_mem",
                        bjou_createTemplateInst(
                            decl_elems,
                            |decl_elems|)),
                    bjou_createArgList(&left, 1))

        result = call
    } else {
        a := bjou_createAccessExpression(left, bjou_createIdentifier(member_name))

        result = a
    }

    translator.created.push(result)

    return CXVisit_Continue  
}

proc v_ArraySubscriptExpr(cursor      : CXCursor,
                          parent      : CXCursor,
                          client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    left  := (_nullptr() as ASTNode*)
    right := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    dispatch(children[0], cursor, client_data)
    left = translator.created.back()
    translator.created.pop()
    
    dispatch(children[1], cursor, client_data)
    right = translator.created.back()
    translator.created.pop()

    translator.indent -= 1
   
    # create result
    s := bjou_createSubscriptExpression(left, right)

    translator.created.push(s)

    return CXVisit_Continue  
}

proc v_CallExpr(cursor      : CXCursor,
                parent      : CXCursor,
                client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    left  := (_nullptr() as ASTNode*)
    _args := [...ASTNode*]
    args  := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    dispatch(children[0], cursor, client_data) # left 
    left = translator.created.back()
    translator.created.pop()

    arg_children := [children, 1:(|children| - 1)]

    foreach child in arg_children {
        dispatch(child, cursor, client_data)
        _args.push(translator.created.back())
        translator.created.pop()
    }

    args = bjou_createArgList(_args.data(), |_args|)

    translator.indent -= 1
   
    # create result
    c := bjou_createCallExpression(left, args)

    translator.created.push(c)

    return CXVisit_Continue  
}

proc v_under(cursor      : CXCursor,
             parent      : CXCursor,
             client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    dispatch(children[0], cursor, client_data) 

    translator.indent -= 1
   
    # create result
    u := translator.created.back()
    translator.created.pop()

    translator.created.push(u)

    return CXVisit_Continue  
}

proc v_DeclRefExpr(cursor      : CXCursor,
                   parent      : CXCursor,
                   client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    spl := nullptr$char()

    r   := clang.getCursorReferenced(cursor)

    if r.kind == CXCursor_FunctionDecl {
        _name         := ClangWrapper.getCursorName(r)
        _mangled_name := clang.getCString(clang.Cursor_getMangling(r))

        if _mangled_name.c_str_startswith("__Z")
            spl = _mangled_name + 1
        else
            spl = _name
    } else {
        spl = ClangWrapper.getCursorName(r)
    }

    # create result
    i := bjou_createIdentifier(spl)

    translator.created.push(i)

    return CXVisit_Continue  
}

proc v_TypeRef(cursor      : CXCursor,
               parent      : CXCursor,
               client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    cx_t := clang.getCursorType(cursor)
    spl  := clang.getCString(clang.getTypeSpelling(cx_t))

    # create result
    i := bjou_createIdentifier(spl)

    translator.created.push(i)

    return CXVisit_Continue  
}

proc v_CStyleCastExpr(cursor      : CXCursor,
                      parent      : CXCursor,
                      client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    expr  := (_nullptr() as ASTNode*)
    ident := (_nullptr() as ASTNode*)
    decl  := (_nullptr() as ASTNode*)

    # visit children
    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    if strcmp(ClangWrapper.getCursorName(children[0]), "bjou_ct_t") == 0 {
        unex := children[1]
        unex_ch := [...CXCursor]
        translator.cw.traverse(unex, child_collector, (&unex_ch) as CXClientData*)
        code := ClangWrapper.getCursorName(unex_ch[0])
        code += 1
        code[strlen(code) - 1] = '\0'

        code' := [...char]
        for i := 0; i < strlen(code); i += 1 {
            if code[i] == '\\'
                i += 1
            code'.push(code[i])
        }
        code'.push('\0')

        multi := bjou_parseToMultiNode(code'.data())
        translator.created.push(multi)
    } else {
        child_idx := |children| - 1

        translator.indent += 1

        dispatch(children[child_idx], cursor, client_data)
        expr = translator.created.back()
        translator.created.pop()
    
        translator.indent -= 1

        t   := clang.getCursorType(cursor)
        l_t := clang.getCursorType(children[child_idx]) 

        if clang.equalTypes(t, l_t) != 0 {
            # create result
            decl = tyToDecl(@translator, &t, cursor)

            a := bjou_createAsExpression(expr, decl)

            translator.created.push(a)
        } else {
            translator.created.push(expr)
        }
    }

    return CXVisit_Continue  
}

proc v_IntegerLiteral(cursor      : CXCursor,
                      parent      : CXCursor,
                      client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*
    
    s := clangextras.getLiteralString(cursor)

    if s.isnull()
        \die{ "could not get integer literal" }

    # create result
    i := bjou_createIntegerLiteral(s)

    delete s

    translator.created.push(i)

    return CXVisit_Continue  
}

proc v_FloatingLiteral(cursor      : CXCursor,
                       parent      : CXCursor,
                       client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*
    
    s := clangextras.getLiteralString(cursor)

    if s.isnull()
        \die{ "could not get float literal" }

    # create result
    f := bjou_createFloatLiteral(s)

    delete s

    translator.created.push(f)

    return CXVisit_Continue  
}

proc v_CharacterLiteral(cursor      : CXCursor,
                        parent      : CXCursor,
                        client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    tokens := translator.cw.getCursorTokens(cursor)
    cxs := clang.getTokenSpelling(translator.cw.tu, tokens[0])
    spl := clang.getCString(cxs)

    # create result
    c := bjou_createCharLiteral(spl)

    translator.created.push(c)

    return CXVisit_Continue  
}

proc v_StringLiteral(cursor      : CXCursor,
                     parent      : CXCursor,
                     client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    spl := ClangWrapper.getCursorName(cursor)
    spl += 1
    spl[strlen(spl) - 1] = '\0'

    # create result
    s := bjou_createStringLiteral(spl)

    translator.created.push(s)

    return CXVisit_Continue  
}

proc v_ReturnStmt(cursor      : CXCursor,
                  parent      : CXCursor,
                  client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    expr := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    if |children| > 0 {
        dispatch(children[0], cursor, client_data) 
        expr = translator.created.back()
        translator.created.pop()
    }

    translator.indent -= 1
   
    # create result

    r := bjou_createReturn(expr)

    translator.created.push(r)

    return CXVisit_Continue  
}

proc c_str_startswith(s1 : char*, s2 : char*) : bool {
    if strlen(s2) > strlen(s1)
        return false

    for i := 0; i < strlen(s2); i += 1
        if s1[i] != s2[i]
            return false

    return true
}

proc unifyElaboratedName(ename : char*) : char* {
    if ename.c_str_startswith("struct ")
        ename[strlen("struct ") - 1] = '_'
    else if ename.c_str_startswith("union ")
        ename[strlen("union ") - 1] = '_'
    else if ename.c_str_startswith("enum ")
        ename[strlen("enum ") - 1] = '_'

    return ename
}

proc v_StructDecl(cursor      : CXCursor,
                  parent      : CXCursor,
                  client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    memberVarDecls := [...ASTNode*] 

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    bit_field_counter := 0
    foreach child in children {
        dispatch(child, cursor, client_data)
        field := translator.created.back()
        bw := clang.getFieldDeclBitWidth(child)
        if bw != -1 {
            if bit_field_counter == 0 {
                bit_field_counter = clang.Type_getSizeOf(clang.getCursorType(child)) * 8
                memberVarDecls.push(field)
            } else {
                bit_field_counter -= bw
            }
        } else {
            memberVarDecls.push(field)
        }
        translator.created.pop()
    }

    translator.indent -= 1
   
    # create result
    name := clang.getCString(clang.getCursorSpelling(cursor))
    if strlen(name) == 0 {
        name = bjou_makeUID("C_struct")
        (@translator).getOrAddAnonTyDecl(clang.getCursorType(cursor), name)
    } else {
        delete name
        name = unifyElaboratedName(clang.getCString(clang.getTypeSpelling(clang.getCursorType(cursor))))
    }

    s := bjou_createStruct(
            name,
            (_nullptr() as ASTNode*),
            memberVarDecls.data(), |memberVarDecls|,
            (_nullptr() as ASTNode**), 0,
            (_nullptr() as ASTNode**), 0,
            (_nullptr() as ASTNode**), 0,
            (_nullptr() as ASTNode**), 0)

    delete name

    translator.created.push(s)
    translator.structs.push(s)

    return CXVisit_Continue  
}

proc v_UnionDecl(cursor      : CXCursor,
                 parent      : CXCursor,
                 client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    cx_t := clang.getCursorType(cursor)
    size := clang.Type_getSizeOf(cx_t)

    decl  := bjou_createDeclarator(
            bjou_createIdentifier("u8"),
            (_nullptr() as ASTNode*),
            (_nullptr() as char**), 0)

    buff : char[32]
    sprintf(buff, "%d", size)
    decl = bjou_createArrayDeclarator(decl, bjou_createIntegerLiteral(buff))

    bytes := bjou_createVariableDeclaration("__bytes", decl, (_nullptr() as ASTNode*))

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    foreach child in children {
        dispatch(child, cursor, client_data)
        if child.kind == CXCursor_FieldDecl
            translator.created.pop()
    }

    translator.indent -= 1
   
    # create result
    name := clang.getCString(clang.getCursorSpelling(cursor))
    if strlen(name) == 0 {
        name = bjou_makeUID("C_union")
        (@translator).getOrAddAnonTyDecl(clang.getCursorType(cursor), name)
    } else {
        delete name
        name = unifyElaboratedName(clang.getCString(clang.getTypeSpelling(clang.getCursorType(cursor))))
    }

    s := bjou_createStruct(
            name,
            (_nullptr() as ASTNode*),
            &bytes, 1,
            (_nullptr() as ASTNode**), 0,
            (_nullptr() as ASTNode**), 0,
            (_nullptr() as ASTNode**), 0,
            (_nullptr() as ASTNode**), 0)
    delete name

    translator.created.push(s)
    translator.structs.push(s)

    return CXVisit_Continue  
}

proc v_EnumDecl(cursor      : CXCursor,
                parent      : CXCursor,
                client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    identifiers := [...char*]

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    foreach child in children {
        ident := ClangWrapper.getCursorName(child)
        identifiers.push(ident)
    }

    translator.indent -= 1

    _name := clang.getCString(clang.getTypeSpelling(clang.getCursorType(cursor)))
    name := { string: }

    if _name.c_str_startswith("enum ")
        name = str(unifyElaboratedName(_name))
    else
        name = concat(str("enum_"), str(_name))

    delete _name

    e := bjou_createEnum(name.c_str(), identifiers.data(), |identifiers|)

    name.free()

    translator.created.push(e)

    return CXVisit_Continue  
}


proc v_FieldDecl(cursor      : CXCursor,
                 parent      : CXCursor,
                 client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    name := ClangWrapper.getCursorName(cursor)

    if bjou_isKeyword(name) {
        s := concat(str("kwd_"), str(name))
        name = bjou_makeUID(s.c_str())
        s.free()
    }

    cx_t := clang.getCanonicalType(clang.getCursorType(cursor))
    decl := tyToDecl(@translator, &cx_t, cursor)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    # foreach child in children {
    #     dispatch(child, cursor, client_data) 
    # }

    translator.indent -= 1
   
    # create result
    v := bjou_createFieldDeclaration(name, decl, (_nullptr() as ASTNode*))

    translator.created.push(v)

    return CXVisit_Continue  
}

proc makeZeroInitExpr(translator : c2bJou ref, t : CXType*, cursor : CXCursor) : ASTNode* {
    k := TypeKind.PLACEHOLDER

    if t.kind == CXType_Void {
        k = TypeKind.VOID
    } else if t.kind == CXType_Bool {
        k = TypeKind.BOOL
    } else if t.kind == CXType_Char_U
      or      t.kind == CXType_UChar
      or      t.kind == CXType_UShort
      or      t.kind == CXType_UInt
      or      t.kind == CXType_ULong
      or      t.kind == CXType_ULongLong
      or      t.kind == CXType_Short
      or      t.kind == CXType_Int
      or      t.kind == CXType_Long
      or      t.kind == CXType_LongLong {
        k = TypeKind.INT
    } else if t.kind == CXType_Char_S
      or      t.kind == CXType_SChar {
        k = TypeKind.CHAR 
    } else if t.kind == CXType_Float
      or      t.kind == CXType_Double
      or      t.kind == CXType_LongDouble {
        k = TypeKind.FLOAT
    } else if t.kind == CXType_Complex {
        k = TypeKind.ARRAY 
    } else if t.kind == CXType_Record
      or      t.kind == CXType_Elaborated {
        name := clang.getCString(clang.getTypeSpelling(@t))
        decl := nullptr$ASTNode()
        if name.c_str_startswith("union (anonymous")
        or name.c_str_startswith("struct (anonymous") {
            delete name
            decl = translator.getOrAddAnonTyDecl(@t, NULL as char*)
        } else {
            if name.c_str_startswith("const ")
                name += strlen("const ")
            if name.c_str_startswith("volatile ")
                name += strlen("volatile ")
            if name.c_str_startswith("restrict ")
                name += strlen("restrict ")

            name = unifyElaboratedName(name)
            decl = declFromName(name)
        }

        return bjou_makeZeroInitExpr(TypeKind.STRUCT, decl)
    } else if t.kind == CXType_Enum {
        k = TypeKind.ENUM
    } else if t.kind == CXType_ConstantArray {
        k = TypeKind.ARRAY
    } else if t.kind == CXType_BlockPointer
      or      t.kind == CXType_Pointer
      or      t.kind == CXType_IncompleteArray {
        decl := makeDeclFromTy(translator, t, cursor)
        return bjou_makeZeroInitExpr(TypeKind.POINTER, decl)
    } else if t.kind == CXType_FunctionProto
           or (t.kind == CXType_Unexposed and clang.getNumArgTypes(@t) != -1) {
        decl := makeDeclFromTy(translator, t, cursor)
        return bjou_makeZeroInitExpr(TypeKind.PROCEDURE, decl)
    } else if t.kind == CXType_Typedef {
        canon := clang.getCanonicalType(@t)
        return makeZeroInitExpr(translator, &canon, cursor)
    } else if t.kind == CXType_Unexposed {
        canon := clang.getCanonicalType(@t)
        spl   := clang.getCString(clang.getTypeSpelling(canon))
        if spl.c_str_startswith("_Atomic(") {
            val_t := clangextras.atomicGetValueType(@t, translator.cw.tu)
            return makeZeroInitExpr(translator, &val_t, cursor)
        } else if strcmp(spl, "_Bool") == 0 {
            k = TypeKind.BOOL
        } else if clang.equalTypes(@t, canon) == 0 {
            return makeZeroInitExpr(translator, &canon, cursor)
        } else {
            \die{ "could not resolve type" }
        }
    } else {
        print "bad type: %", t.kind
        \die{ "c2bjou: unable to translate type" }
    }

    return bjou_makeZeroInitExpr(k, nullptr$ASTNode()) 
}

proc tyToDecl(translator : c2bJou ref, t : CXType*, cursor : CXCursor) : ASTNode* {
    # if translator.types.find(t).isnull()
    #     translator.types.insert(t, makeDeclFromTy(translator, t))
    # return bjou_clone(translator.types[t])
    return makeDeclFromTy(translator, t, cursor)
}

proc declFromName(name : char*) : ASTNode* {
    id := bjou_createIdentifier(name)
    return bjou_createDeclarator(
                id,
                (_nullptr() as ASTNode*),
                (_nullptr() as char**), 0)
}

proc makeDeclFromTy(translator : c2bJou ref, t : CXType*, cursor : CXCursor) : ASTNode* {
    
    decl := (_nullptr() as ASTNode*)

    if        t.kind == CXType_Void {
        decl = declFromName("void")
    } else if t.kind == CXType_Bool {
        decl = declFromName("bool")
    } else if t.kind == CXType_Char_U
      or      t.kind == CXType_UChar {
        decl = declFromName("u8")
    } else if t.kind == CXType_UShort {
        decl = declFromName("u16")
    } else if t.kind == CXType_UInt {
        decl = declFromName("u32")
    } else if t.kind == CXType_ULong or t.kind == CXType_ULongLong {
        decl = declFromName("u64")
    } else if t.kind == CXType_Char_S
      or      t.kind == CXType_SChar {
        decl = declFromName("char")
    } else if t.kind == CXType_Short {
        decl = declFromName("i16")
    } else if t.kind == CXType_Int {
        decl = declFromName("i32")
    } else if t.kind == CXType_Long or t.kind == CXType_LongLong {
        decl = declFromName("i64")
    } else if t.kind == CXType_Float {
        decl = declFromName("f32")
    } else if t.kind == CXType_Double {
        decl = declFromName("f64")
    } else if t.kind == CXType_LongDouble {
        decl = declFromName("f128")
    } else if t.kind == CXType_Complex {
        elem_t := clang.getElementType(@t)
        elem_decl := makeDeclFromTy(translator, &elem_t, cursor)
        decl = bjou_createArrayDeclarator(elem_decl, bjou_createIntegerLiteral("2"))
    } else if t.kind == CXType_Record
           or t.kind == CXType_Elaborated {
        name := clang.getCString(clang.getTypeSpelling(@t))
        if name.c_str_startswith("union (anonymous")
        or name.c_str_startswith("struct (anonymous") {
            delete name
            decl = translator.getOrAddAnonTyDecl(@t, NULL as char*)
        } else {
            if name.c_str_startswith("const ")
                name += strlen("const ")
            if name.c_str_startswith("volatile ")
                name += strlen("volatile ")
            if name.c_str_startswith("restrict ")
                name += strlen("restrict ")

            name = unifyElaboratedName(name)
            decl = declFromName(name)
        }
    } else if t.kind == CXType_Enum {
        _name := clang.getCString(clang.getTypeSpelling(@t))
        name := { string: }

        if _name.c_str_startswith("enum ")
            name = str(unifyElaboratedName(_name))
        else
            name = concat(str("enum_"), str(_name))

        delete _name

        decl = declFromName(name.c_str())
        
        name.free()
    } else if t.kind == CXType_ConstantArray {
        elem_t := clang.getElementType(@t)
        elem_decl := makeDeclFromTy(translator, &elem_t, cursor)
        size := clang.getNumElements(@t)
        buff : char[32]
        sprintf(buff, "%d", size)
        decl = bjou_createArrayDeclarator(elem_decl, bjou_createIntegerLiteral(buff))
    } else if t.kind == CXType_BlockPointer {
        decl = bjou_createPointerDeclarator(declFromName("void"))
    } else if t.kind == CXType_Pointer {
        elem_t := clang.getPointeeType(@t)

        if elem_t.kind == CXType_FunctionProto
        or (elem_t.kind == CXType_Unexposed and clang.getNumArgTypes(elem_t) != -1) {
            decl = makeDeclFromTy(translator, &elem_t, cursor)
        } else {
            decl = bjou_createPointerDeclarator(makeDeclFromTy(translator, &elem_t, cursor))
        }
    } else if t.kind == CXType_IncompleteArray {
        elem_t := clang.getElementType(@t)
        elem_decl := makeDeclFromTy(translator, &elem_t, cursor)
        decl = bjou_createPointerDeclarator(elem_decl)
    } else if t.kind == CXType_FunctionProto
           or (t.kind == CXType_Unexposed and clang.getNumArgTypes(@t) != -1) {
        paramDecls := [...ASTNode*]

        isVararg := clang.isFunctionTypeVariadic(@t) == 1   
        n_argTypes := clang.getNumArgTypes(@t)

        for p := 0; p < n_argTypes; p += 1 {
            param_t := clang.getArgType(@t, p)
            paramDecls.push(makeDeclFromTy(translator, &param_t, cursor))
        }

        ret_t := clang.getResultType(@t)
        retDecl := makeDeclFromTy(translator, &ret_t, cursor)
       
        decl = bjou_createProcedureDeclarator(paramDecls.data(), |paramDecls|, retDecl, isVararg)

        paramDecls.free()
    } else if t.kind == CXType_Typedef {
        canon := clang.getCanonicalType(@t)
        decl = makeDeclFromTy(translator, &canon, cursor)
    } else if t.kind == CXType_Unexposed {
        canon := clang.getCanonicalType(@t)
        spl   := clang.getCString(clang.getTypeSpelling(canon))
        if spl.c_str_startswith("_Atomic(") {
            val_t := clangextras.atomicGetValueType(@t, translator.cw.tu)
            decl   = makeDeclFromTy(translator, &val_t, cursor)
        } else if strcmp(spl, "_Bool") == 0 {
            decl = declFromName("bool")
        } else if clang.equalTypes(@t, canon) == 0 {
            decl = makeDeclFromTy(translator, &canon, cursor)
        } else {
            \die{ "could not resolve type" }
        }
        delete spl
    } else {
        print "bad type: %", t.kind
        \die{ "c2bjou: unable to translate type" }
    }

    bjou_setContext(decl, getCursorContext(cursor))

    return decl
}
