# __dynamic_array.bjou

module __dynamic_array

type __bjou_dyn_array$T {
    const INIT_SIZE := 8

    __data		: T*
    __capacity 	: u64
    __used		: u64

    proc create() : __bjou_dyn_array$T {
        return  { __bjou_dyn_array$T: 
            .__capacity = __bjou_dyn_array$T.INIT_SIZE,
            .__used     = 0,
            .__data     = new T[__bjou_dyn_array$T.INIT_SIZE]
        }
    }
}

proc free$T(da : T[...] ref) {
    delete \__da_data{da}
    \__da_capacity{da} = 0
    \__da_used{da} = 0
}

\static_if { \abc{}
    proc __bjou_dynamic_array_subscript$T(
            _s     : T[...] ref, # the dynamic array
            _i     : u64,        # the index
            _loc_f : char*,      # call site file
            _loc_l : int,        # call site line
            _loc_c : int)        # call site character
            : T ref {

        if _i >= |_s|
        or _i < 0 {
            buff : char[1024]
            buff.sprintf("dynamic array index out of bounds (index = %llu, length = %llu)\n    at %s :: %d :: %d",
                         _i, |_s|, _loc_f, _loc_l, _loc_c)
            \die{ buff }
        }

        return \__da_data{_s}[_i]
    }
}
\static_if { not \abc{}
    proc __bjou_dynamic_array_subscript$T(_s : T[...] ref, _i : u64) : T ref {
        return \__da_data{_s}[_i]
    }
}

proc resize$T(da : T[...] ref, size : u64) {
    da.resize(size, zinit$T())
}

proc resize$T(da : T[...] ref, size : u64, val : T) {
	_d := getref(\__da_data{da})
	_c := getref(\__da_capacity{da})
	_u := getref(\__da_used{da})

	if size < _u {
		_u = size
	} else {
        __u := unref(_u)

        while _c < size
            da.__bjou_dynamic_array_grow()

        _u = size

		for i := 0; i < (size - __u); i += 1
            _d[i] = val
	}
}

proc __bjou_dynamic_array_grow$T(da : T[...] ref) {
    _d := getref(\__da_data{da})
    _c := getref(\__da_capacity{da})
    _u := getref(\__da_used{da})

    _c *= 2
    new__data := new T[_c]
    mcopy(new__data, _d, _u * sizeof T)
    delete _d
    _d = new__data
}

proc __bjou_dynamic_array_shrink$T(da : T[...] ref) {
    _d := getref(\__da_data{da})
    _c := getref(\__da_capacity{da})
    _u := getref(\__da_used{da})

    _c /= 2
    new__data := new T[_c]
    mcopy(new__data, _d, _u * sizeof T)
    delete _d
    _d = new__data
}

proc len$T(da : T[...] ref) : u64 {
    return |da|    
}

# push by val
proc push$T(da : T[...] ref, item : T) {
    _d := getref(\__da_data{da})
    _c := getref(\__da_capacity{da})
    _u := getref(\__da_used{da})

    # make space if necessary
    if _u == _c
        da.__bjou_dynamic_array_grow()

    # put the item in
    _d[_u] = item

    _u += 1
}

# push by ref
proc push$T(da : T[...] ref, item : T ref) {
    _d := getref(\__da_data{da})
    _c := getref(\__da_capacity{da})
    _u := getref(\__da_used{da})

    # make space if necessary
    if _u == _c
        da.__bjou_dynamic_array_grow()

    # put the item in
    _d[_u] = item

    _u += 1
}

proc pop$T(da : T[...] ref) {
    _d := getref(\__da_data{da})
    _c := getref(\__da_capacity{da})
    _u := getref(\__da_used{da})

    if _u == 0
        return

    _u -= 1

    if _u < (_c / 2)
    and _c > __bjou_dyn_array$T.INIT_SIZE
        da.__bjou_dynamic_array_shrink()
}

proc back$T(da : T[...] ref) : T ref {
    if |da| == 0
        \die{ "called back() on an empty dynamic array" }
    return da[|da| - 1]    
}

proc clear$T(da : T[...] ref) {
    \__da_used{da} = 0    
}

proc erase$T(da : T[...] ref, idx : u64) {
    if |da| == 0
        \die{ "called erase() on an empty dynamic array" }
    da[idx] # bounds check
    _d := getref(\__da_data{da})
    _u := getref(\__da_used{da})

    mmove(_d + idx, _d + idx + 1, (_u - idx - 1) * sizeof T)
    da.pop()
}

proc data$T(da : T[...] ref) : T* {
    return \__da_data{da}    
}

proc set$T(da : T[...] ref, data : T[]) {
    # clear all old
    delete \__da_data{da}
    da = [...T]

    _d := getref(\__da_data{da})
    _c := getref(\__da_capacity{da})
    _u := getref(\__da_used{da})

    # make space
    while _c < |data|
        da.__bjou_dynamic_array_grow()

    _u = |data|

    # copy
    mcopy(_d, \__slice_data{data}, _u * sizeof T)
}

proc copy$T(da : T[...] ref) : T[...] {
    c : T[...] = da

    _d := getref(\__da_data{c})
    _c := getref(\__da_capacity{c})
    _u := getref(\__da_used{c})
    
    _d = new T[_c]

    mcopy(_d, \__da_data{da}, _u * sizeof T)

    return c
}

proc sort$T(da : T[...] ref) {
    proc _swap(a : T ref, b : T ref) {
        tmp := unref(a)
        a    = unref(b)
        b    = tmp
    }

    proc _sort(arr : T*, l : u64, r : u64) {
        if l >= r    return

        pivot := arr[l]

        l' := l
        r' := r

        while l' < r' {
            while arr[l'] < pivot    l' += 1
            while pivot < arr[r']    r' -= 1
            _swap(arr[l'], arr[r'])
        }

        _swap(pivot, arr[l'])

        _sort(arr, l, l')
        _sort(arr, l' + 1, r)
    }

    _d := \__da_data{da}
    _u := \__da_used{da}

    if _u == 0    return

    _sort(_d, 0, _u - 1)
}

proc find$T(da : T[...] ref, val : T) : i64 {
    for i := 0; i < |da|; i += 1 {
        if da[i] == val
            return i
    }
    return -1
}

