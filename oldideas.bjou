type One <T, #expr> {
    t : T = expr
}

ci :: 4 + 5
vi := 4

num :: 1 + 2 * 3

pi :: 355.0 / 113.0

TWOPI :: pi * 2.0

example : One!<Int, [ci]>
other : One!<Int, [10]>
/*
f : Float = f

proc sum<T>(a : T, b : T) -> T
    return a + b

i := 1
j := 2

sum(&i, &j)
*/
/*

/*
 *  - procedure generator based on arg of map and inferred return type
 *      - compile time macro '$$'
 *  - if procedure is only one statement, 'return' is not necessary
 */

namespace String {
    extern atoi(Char*) -> Int

    namespace C {
        proc ToInt(char_ptr : Char*) -> Int
            atoi(char_ptr)
    }
}

collection = "3,2,1"                                // "3,2,1"
    ->split(',')                                    // ["3", "2", "1"]
    ->map(String.C.ToInt)                           // [3, 2, 1]
    ->where($$ $1 % 2 != 0)                         // [3, 1]
    ->sort($$ $1 < $2)                              // [1, 3]
    ->transform($$ $1 * $1)                         // [1, 9]
    ->done()

*/

/*

namespace List {
    type List <T> {
        next : List<T>*?
        _t : T
    }

    proc map<colT from Collection, T, retT>(this : coerce colT!<T>*, call : (T*) -> retT) -> colT!<retT> {
        m : colT!<retT>;
        for item in @this m->append(call(item))
        return m
    }

    operator "[]" proc <T> (list : coerce List!<T>*, idx : u64) -> T {
        while idx != 0 {
            if not list.next ?? list
                fail("List subscript out of bounds.")
            idx -= 1
        }
        return list._t
    }

    namespace Exceptional {
        operator "[]" proc <T> (list : coerce List!<T>*, idx : u64) -> Exceptional!<T> {
            while idx != 0 {
                if not list.next ?? list
                    return Exceptional.Make<T>(nothing, ECode.BadSubscript, "List subscript out of bounds.")
                idx -= 1
            }
            return Exceptional.Make(list._t)
        }
    }
}

*/
    
/*
type One <T, #expr> {
    t : T = expr;
}

ci :: 4 + 5;
vi := 4;

num :: 1 + 2 * 3;

pi :: 355.0 / 113.0;

TWOPI :: pi * 2.0;

example : One!<Int, [ci]>;
other : One!<Int, [10]>;

iarray := { 1, 2, 3, 4 };

type Person {
    name : Char*;
    age : Int;
    male : Bool;
}

bob :: { Person: "Bob", 40, 1 > ci };

same :: { Person: "Bob", 40, 1 > ci } == { Person: "Bob", 40, false };

type User<#p> {
    person := p;
    password : Char*;
}

p1 : User!<[{ Person: "Bob", 40, 1 > ci }]>;
p2 : User!<[{ Person: "Bob", 40, true }]>;

type Two <T> {
    a : T;
    b : T;
}

twoi :: { Two!<Int>: "1", 2 };
*/

/*
type TupleElem <#idx, T> {
    val : T;
}

type 

type Tuple <...Ts> extends $expand(idx from $range(0, $nargs(Ts)), T from Ts) TupleElem!<{ idx }, T> {
    size : u64 = $nargs(Ts);
}

size :: proc <T from Tuple> (tup : coerce T*) -> u64 { return tup.size; };

get :: proc <T from Tuple<...Ts>, #idx> (tup : coerce T*) -> $at(Ts, idx) {
    return (T as TupleElem!<{ idx }, $at(Ts, idx)> *).val;
};

namespace Lambda {
    type Capture <...#members> {
        $expand(mem from members) $var($identifier(mem), $typeof(mem), mem);
    }

    type Lambda <...#vars, callT> {
        captures : Capture!<vars>;
        call : callT;
    } 
    Create :: proc <...#vars, callT> (call : callT) -> Lambda!<vars, callT> {
        l : Lambda!<vars, callT>;
        l.call = call;
    };
    operator "()" proc <T from Lambda<...#members, callT>, ...#args> (lamda : coerce T*) -> $returntype(callT) {
        return lamda.call($expand(args));
    };
}


array : Int[] = { 1, 2, 3, 4 };
i := 1;
array->map(Lambda.Create<{ i }>(proc (element : coerce Int*) {
    @element += i;
}));
*/



/*
Make :: proc () -> One!<Int, {{ 1, 2, 3, i }}> {

};*/

/*
pfactory :: proc (a : (Int), b : () -> Char*) -> (Int) -> u8* {

};


type T <#p1, #p2> {
    v1 := p1();
    v2 := p2();
}

i :: proc () -> i32  { return 1;            };
s :: proc () -> u8*  { return "hello";      };
f :: proc () -> f32  { return 1.0;          };
b :: proc () -> Byte { return 100 as Byte;  };

t :: proc () -> T!<{ i }, { s }> { 
    ret : T!<{ i }, { s }>;
    return ret; 
};

main :: proc () {
    val : T!<{ t }, { b }>;
};
*/



/*

namespace std {
    type Vector3 {
        x : i64;
        y : i64;
        z : i64;
    }

    namespace List {
        type List <T> {
            _prev : List!<T>*? = nothing;
            _next : List!<T>*? = nothing;
            _t : T;
        }
    }
}

namespace MoreTypes {
    alias c_str u8*;
}

type map <#expr> {
    val := expr;
}

main :: proc () {
    l1 : std.List.List!<MoreTypes.c_str>;
    l2 : std.List.List!<std.List.List!<std.Vector3>>;
    v : std.Vector3;
    m := new map!<{new Int}>;
};

*/

/*
namespace Exceptional {
    type Exceptional<T> {
        _t : T? = nothing;
        code : Int;
        what : String;
    }
    
    Make :: proc <T> (__t : coerce T?*, _code : Int, _what : String) -> Exceptional!<T> {
        e : Exceptional!<T>;
        e = { @__t, _code, _what };
        return e;
    };
    
    Make :: proc <T> (__t : coerce T?*) -> Exceptional!<T> {
        assert(__t?);
        e : Exceptional!<T>;
        e = { @__t, 0, "" };
        return e;
    };
    
    operator "?" proc <T> (e : coerce Exceptional!<T>*) -> Bool {
        return e._t?;
    };

    operator "??" proc <T> (e : coerce Exceptional!<T>*, dest : coerce T*) -> Bool {
        return e.__t ?? dest;
    };
}

namespace File {
    alias CFile FILE*;
    
    fopen :: extern fopen(u8*, u8*) -> CFile;
    
    enum ECode {
        Good,
        NoFile,
        BadFormat,
        BadPermissions
    }
    
    type File {
        c_file : CFile;
    }
    
    Open :: proc (path : u8*) -> Exceptional!<File> {
        c_file := fopen(path, "r+");
        if (c_file) {
            file : File;
            file.c_file = c_file;
            return Exceptional.Make(some (file));
        } else return Exceptional.Make(nothing, ECode.NoFile, "File not found");
    };
}

main :: proc () {
    efile : Exceptional!<File> = Open("somefile");
    file : File;
    
    while (not efile ?? file) {
        match (efile.code) {
            with File.ECode.NoFile:
                print "File does not exist." + efile.what;
            with File.ECode.BadFormat:
                print "Bad file format" + efile.what;
            with else: efile.what;
        }
        efile = Open("somefile");
    }

    print "%", file->lines()[0];
};
*/




/*
namespace std {
    type Ray <T> {
        data : T*? = nothing;
        len : u64 = 0;
    }

    alias iRay Ray!<Int>;
}*/

/*
pi :: 3.14159;

alias Char u8;

namespace std {
    namespace String {
        alias c_str u8*;
        
        type String {
            data : c_str? = nothing;
            len := 0;
        }
        
        set :: proc (this : String*, chars : c_str) {
            /* ... */
        };
    }
}

namespace std {
    type Ray<T> {
        data : T*? = nothing;
        len := 0;
    }
    namespace String {
        append :: proc (this : String*, chars : c_str) -> String {
            /* ... */
        };
    }
} */

/*
alias AnalyzeUtil   (BaseNode*) -> Bool;
alias GenerateUtil  (BaseNode*) -> Bool;
type ModuleUtil {
    Import : (BaseNode*, std.BinaryFile*);
    Export : (BaseNode*, std.BinaryFile*);
}

type NodeUtil {
    Analyze     : AnalyzeUtil;
    Generate    : GenerateUtil;
    Module      : ModuleUtil;
}

type BaseNode<#NodeUtilInit> {
    context : Context;
    Util : NodeUtil = NodeUtilInit;
}

type Node<NodeT, #NodeUtilInit> extends NodeT!<BaseNode!<{NodeUtilInit}>> {}

type If<BaseNodeT> extends BaseNodeT {
    conditional : BaseNode*;
    statements  : std.Ray!<BaseNode*>;
    _else       : BaseNode*;
}

IfUtil :: { AnalyzeIf, GenerateIf, { ImportIf, ExportIf } };

alias IfNode Node!<If, {IfUtil}>;

parseIf :: proc () -> BaseNode*? {
    result := new IfNode;
    result.context = current_context;
    
    if (optional(KWD_IF)) {
        expect(L_PAREN, "'('");
        
        parse_expression() ? conditional { 
            result.conditional = conditional;
        } else { errorlb(current_context, "Invalid conditional expression for 'if' statement."); };
        
        expect(R_PAREN, "')'");
        
        if (optional(L_CURLY_BRACE)) {
            while (!optional(R_CURLY_BRACE, nullptr, true)) {
                parse_statement() ? statement {
                    result.statements->append(statement);
                } else { break; };
            }
            expect(R_CURLY_BRACE, "'}'");
        } else parse_statement() ? statement {
                result.statements->append(statement);
        } else { errorlb(current_context, "Expected statement as body in 'if' statement."); };
        
        parse_else() ? _else { result._else = _else; };
        
        return some result as BaseNode*;
    }
    return nothing;
};

alias Parser () -> BaseNode*?;

parse :: proc () -> BaseNode*? {
    parse_options := {
        parseIf // ...
    };
    node : BaseNode*?; 
    for (i := 0; i < parse_options->count(); i += 1) {
        node = parse_options[i]();
        node ? ret { return node; };
    }
    return nothing;
}

main :: proc (argc : Int, argv : Char**) {
    nodes : std.Ray!<BaseNode*?>;
    
    while (parse() ? node { 
        nodes->append(node); 
    }){}

    for (i := 0; i < nodes->size(); i += 1) {
        node := nodes[i];
        if (node->node.Util.Analyze()) {
            node->node.Util.Module.Export(std.OpenBinaryFile("module"));
            node->node.Util.Generate();
        }
    }
};

enum Colors {
    RED,
    GREEN,
    BLUE
}

operator "/" extern div(Int, Int) -> div_t;

operator "=" proc (left : String, right : String) -> String {
    /* ... */
};

stringCat :: proc (left : String, right : String) -> String {
    /* ... */
};

operator "+" stringCat;
*/

/*

/************************************
              demo.bjou
*************************************/

// Hello, bJou
    /* nested comments come in handy */

    // implicit main

    print "Hello, world!";


// Variables, type intelligence
     /**************************/
    
    num : Int;
    word : Char* = "Foo";
    
    new_num : Int* = new Int; // dynamic allocation with 'new' and 'delete'
    
    // type inferrence
    floatingpt := 12.345; // compiler deduces that floatingpt must be a Float
    new_char := new Char;
    
    @new_char = 'b'; // dereference with '@' -- '&' for address is the same as C
    
    // compiler uses this information other places too
    print "num: %, word: %, floatingpt: %, new_char: %", num, word, floatingpt, @new_char;
    
    delete new_num; 
    delete new_char;
    
    array : Int[10]; // arrays work


// Constants
     /*******/
     
     // constants take advantage of type inferrence since they must have an associated expression
     PI :: 355.0 / 113.0; // NOT computed at run time
     print "π = %", PI;
     pi := PI;
     TWO_PI :: 2.0 * PI;

     print "2 x % = %", PI, TWO_PI;
     
     i := 1;
     // ZERO :: i - 1; // not a constant expression -- will not compile


// Procedures
     /********/
     
     // procedures are just like any other data type
     // can be stored, passed, returned, etc.
     // there is a procedure literal syntax
     
     // storage variable for a procedure that adds two Ints and returns the result
     add : (Int, Int) -> Int;
     // we can set 'add' with a procedure literal expression
     add = proc (a : Int, b : Int) -> Int {
         return a + b;
     };
     // calling 'add' works as expected
     print "% + % = %", 1, 2, add(1, 2);
     
     // BUT internally, we are using function pointers which could slow down our program substantially
     // SOLUTION: procedures can be attached to a constant, so no pointer is needed
     
     say_hello :: proc (name : Char*) {
         print "Hello, %!", name;
     };
     
     say_hello("bJou"); // direct call - no pointer involved
     
     // Yes, recursion works
     factorial :: proc (i : Int) -> Int {
         if (i == 1)
            return 1;
         return i * factorial(i - 1);
     };
     print "factorial(5) = %", factorial(5);
     
     /*     Neat Tricks     */
     // call a procedure literal without attaching it to a variable or constant
     proc () { print "I'm anonymous."; }(); // no pointer dereferencing is happening here     
     // pass and return procedures
     factory :: proc (input_proc : () -> Int) -> () -> Char* {
         if (input_proc() % 2 == 0)
            return proc () -> Char* { return "input_proc() returned an even number."; };
         return proc () -> Char* { return "input_proc() returned an odd number."; };
     };
     print "%", factory(proc () -> Int { return 1; })(); // pass by literal
     // type inferrence works for procedure types too!
     even := proc () -> Int { return 2; };
     print "%", factory(even)(); // pass by variable


// Talking to C
     /**********/
     
     // this language is very closely related to C and is designed to be very cooperative with C code
     // since C procedures will already be defined, we just have to have a way to refer to them
     // 'extern' and a procedure signature is the syntax for an external procedure literal expression
     
     print "Hello, %!", extern getenv(Char*) -> Char* ("USER"); // again, we can call the literal
     // all of the same propterties of procedures apply to extern procedures as well
     sleep :: extern sleep(Int);
     call_sleep := proc (p : (Int)) {
         print "Sleeping for 3 seconds.."; 
         p(3); 
     };
     call_sleep(sleep);
     // the C code just has to be linked using '-l' flag
     extern print_hello()();


// Procedure Overloading
     /*******************/
     
     // constants that refer to procedure types may be overloaded
     // all internal procedures are name-mangled
     add :: proc (a : Int, b : Int) -> Int { return a + b; };
     add :: proc (a : Float, b : Float) -> Float { return a + b; };
     
     // the compiler selects the correct overload based on arguments when called
     print "1 + 2 = %", add(1, 2);
     print "2.3 + 4.5 = %", add(2.3, 4.5);
     
     // when assigning to a variable, we the type of the variable must be explicit
     addi : (Int, Int) -> Int = add;
     addf : (Float, Float) -> Float = add;
     // a := add; // does not work here
     
     // even constants associated with external procedures can be overloaded
     printf :: extern printf(Char*, ...) -> Int;
     printf :: proc () {
         print "f";
     };
     
     printf("I am the true printf()\n");
     printf();


// Defining Types
     /************/

    // Types in bJou follow the POD (Plain Old Data) model like C
    // I try to keep data and methods of working with that data separate in 
    // design and make it obvious when they are together (more on that later)
    
    NULLNode :: 0 as LinkedListNode*; // casting for a makeshift NULL
    
    type LinkedListNode {
        data : Float;
        next : LinkedListNode* = NULLNode; // struct member initialization!
        prev : LinkedListNode* = NULLNode;
    }
    
    type LinkedList {
        // type inferrence works in struct definitions!
        length := 0;
        current := NULLNode; 
    }
    
    type Base {
        c : Char;
        message := "I am of type Base";
    }
    type Derived extends Base {
        num := 12345; // adding a member
        // member redefinitions override the initializer if types match
        message := "I am of type Derived";
    }
    
    b : Base;
    d : Derived;
    print "%\n%", b.message, d.message;


// Working with structs, the injection operator
     /******************************************/
     
     type Point {
         x := 0.0;
         y := 0.0;
     }
     
     // normal procedures that take structs as arguments
     distance :: proc (p1 : Point*, p2 : Point*) -> Float {
         x := p1.x - p2.x; // '.' access works for structs and pointers to structs
         y := p1.y - p2.y;
         
         return extern sqrt(Float) -> Float(x*x + y*y);
     };
     
     origin : Point;
     p : Point;
     p.x = 3.0;
     p.y = 4.0;
     print "Distance between the origin and p is %", distance(&origin, &p);
     
     translate :: proc (this : Point*, x : Float, y : Float) {
         this.x = this.x + x;
         this.y = this.y + y;
     };
     
     translate(&p, 1.0, 1.0); // this works as expected
     // the injection operator (->) takes the left operand and injects it as the
     // first argument in the next call of the expression.
     // the operator also coerces the left operand to a pointer if it isn't one
     p->translate(1.0, 1.0); // makes it clear that we are working with 'p' as the subject
     print "Distance between the origin and p is %", origin->distance(&p);
     
     // works across the board
     type FILE {}
     fopen      :: extern fopen(Char*, Char*) -> FILE*;
     fclose     :: extern fclose(FILE*) -> Int;
     fprintf    :: extern fprintf(FILE*, Char*, ...) -> Int;
     file := fopen("demo.txt", "w");
     file->fprintf("Injection operator!");
     file->fclose();


// Non-Linear Compiler Logic
     /***********************/
     
     // Unlike C and C++, dependencies and definitions do not need to be written
     // in a linear fashion
     // The compiler works hard to sort that stuff out for you
     
     // completely backwards ordering of code structure
     p : Person;
     p->print_name();
     
     print_name :: proc (this : Person*) { print "%", this.name; };
     
     type Person {
         name := "Red Beard";
     }


// Exercise: Roll your own virtualism*/


     /********************************/

     // for virtualism, the procedure DO need to be part of the data
     // bJou tries to make this clear
  
     type Animal {
         // 'speak' is a member that holds a procedure
         speak := proc (this : Animal*) {
             print "I don't know what I am."; 
         };
     }
     
     type Dog extends Animal {
         breed := "Golden Retriever"; // adding string member
         speak := proc (_this : Animal*) { // override 'speak' initializer
            this := _this as Dog*;
            print "The % says 'bark!'.", this.breed;    
         };
     }

     // similar thing for a cat
     type Cat extends Animal {
         num_legs := 4;
         speak := proc (_this : Animal*) {
             this := _this as Cat*;
             print "A cat with % legs says 'meow'.", this.num_legs;
         };
     }
     
     animals : Animal*[3]; // store 3 animals as pointers to the base type
     animals[0] = new Animal;
     animals[1] = new Dog as Animal*;
     animals[2] = new Cat as Animal*;
     
     animals[0]->animals[0].speak();
     delete animals[0];
     animals[1]->animals[1].speak();
     delete animals[1];
     animals[2]->animals[2].speak();
     delete animals[2];


*/
