# c2bjou
# source to source translator from C to bJou
# uses libclang

\run{ main() }

############# run time code
print "running benchmark.."
mybenchmark()
print "done"
###########################

\ct {
const C_FILE    := "fact.c"
const PRINT_AST := false

import "null.bjou"

import "dict.bjou"

# must be defined for clang.bjou to compile
const libclang_path := "/usr/local/Cellar/llvm/5.0.1/lib/libclang.dylib"
import "clang.bjou"
import "ClangWrapper.bjou"
import "visitors.bjou"

import "compiler.bjou"


proc main() {
    init_clang()

    cw := ClangWrapper.create()
    translator := c2bJou.create(cw)

    translator.cw.parseTU(C_FILE)

    translator.cw.traverseTU(dispatch, (&translator) as CXClientData*)

    # run passes on translated nodes
    gs := bjou_getGlobalScope()

    foreach node in translator.created {
        bjou_appendNode(node)
        bjou_setGlobalNodeRP(node)
        bjou_addSymbols(node, gs)
    }
    foreach node in translator.created
        bjou_analyze(node)
}

type c2bJou {
    cw            : ClangWrapper ref
    visitor_table : visitor_t[CXCursor_END_]
    indent        : int
    types         : dict$(CXType*, ASTNode*)
    created       : ASTNode*[...]

    proc create(cw : ClangWrapper ref) : c2bJou {
        c := { c2bJou:
            .cw            = cw,
            .indent        = 0,
            .types         = dict$(CXType*, ASTNode*).create(),
            .created       = [...ASTNode*]
        }

        init_visitor_table(c.visitor_table)

        return c
    }
}
}
