-- templates with types within proc args crash compiler
[
    proc p$T(arg : <(T)>) { }
]
    -- This is why we need a dumber name mangler.
       I say we just do some sort of hashing and use those.
       Leave readablity of the generated binary to debug information.
       Would be simpler, faster, and less error prone (I think).

    -- Related problems with tuple arguments

-- multiple \static_do directives don't work.. symbols blah blah

-- member procs don't work through extended types... more name mangling problems
[
    type A {
        proc p() {}
    }

    type B extends A {}

    b := { B: }
    b.p()
]

-- symbol resolution in interfaces is broken
[
    interface I { proc(this) : string }
]

-- missing interface symbol lacks context
[
    type T {
        implements missing
    }
]

-- 'run' macro should call __bjou_rt_init or at least complete the same tasks before executing code

-- Need a better way to manage when macros are executed and when/if their children are analyzed
[
    static_if{ cond
        type T {} }
    static_if{ not cond
        type T {} }
]

-- LLVM 7 isn't working

-- should template define elements be checked against other symbols?
[
    type A {}
    type T$A { field : A }
]

-- with the new symbol system, we use Declarator::asString to create template proc symbols..
   This can cause duplication of code when the declarators used to instantiate a template are
   different names for the same type. There isn't a problem except for code bloat.
[
    proc p$T(t : T) {}
    p$int(1)
    p$i32(2)
]

-- check for uninitialized references in zero-initialized fields of a struct
[
    type A { field : int ref }
    type B { a : A }
    { B: }
]
