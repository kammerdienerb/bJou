# arrayideas.bjou

# array implementation:
type array!(T) {
    __data : T*
    __size : long
}

# abc on by default. Off with a compiler flag. (how to localize? macro region?)

macro noabc { "{" (b : $$block) "}" } {
    $insert_abcoff{}
    $(b)
    $insert_abon{}
}

proc fill!(T)(a : T[], val : T) {
    $loopparallel { $vectorop { $noabc {
        foreach i in range(0, a.len() - 1)
            a[i] = val
    }}}
}

a : int[5]
a.fill(0);

macro $range { (start : $$expr) "..." (end : $$expr) } {
    range($(start), $(end))
}

$noabc {
    foreach i in $range{ 0 ... 9 }
        print "%", a[i]
}

macro array { (t : $$type) ":" (e : $$exprs) } {
    <<  $_ : $(t)[$len{$(e)}]
        $(*e){$_.push($(e))}
        <-$_
    >>    
}

macro slice { "[" (a : $$expr) "]" } {
    [$(a), 0:$(a).len()]    
}

myarray := $array{ string: "this", "is", "an", "array", "literal", "(kinda)" }
myslice := $slice{ myarray }

# slice implementation (is the same data-wise)
type slice!(T) {
    __data : T*
    __size : long
}

# type declarators:
a : int[10] # array -- must have size, allocates, calls destroy at end of lifetime
s : int[] # slice -- size not specified, does not allocate, does not destroy

# slice syntax:
s = [a, 2:5] # [array, start:size]

n := new int[32] # returns int[] (slice) where len = 32
delete n

(proc main() {
    str     : string = "Hello, world!"
    slice   : char[] = [str.slice(), 7:5] # slice of slice is OK.

    for ch in slice # ch is char&
        print ch.toupper()
})()

# W
# O
# R
# L
# D

# need some sort of read only slice...

----------------------------------------------------------------------------------

s := "the quick brown fox"

macro itsplit { (e : $$expr) } { $(e).slice().iter::split() }

macro ter { (i : $$expr) "?" (t : $$expr) ":" (e : $$expr) } {
    $inline {
        $lambda { [&]():
            if $(i) return $(t)
            else    return $(e)
        }()
    }    
}

macro ter2 { (i : $$expr) "?" (t : $$expr) ":" (e : $$expr) } {
    <<  if      $(i) <-$(t)
        else    <-$(e) >>
}

foreach word in $itsplit{s}
    print "%", $ter{ word.hasnext() ? word + ", " : word }
   
foreach word in $itsplit{s}
    print "%", << if word.hasnext() <-(word + ", ") else <-word >>




