# visitors.bjou

module c2bjou_visitors

extern sprintf(char*, char*, ...) : int

import "clang.bjou"
import "compiler.bjou"

import "dltr.bjou"

type visitor_t = <(CXCursor,      # cursor
                   CXCursor,      # parent
                   CXClientData*) # client_data
                   : u32>

proc child_collector(cursor      : CXCursor,
                     parent      : CXCursor,
                     client_data : CXClientData*) : u32 {

    children := getref(@(client_data as CXCursor[...]*))

    children.push(cursor)  

    return 1
}

proc dispatch(cursor      : CXCursor,
              parent      : CXCursor,
              client_data : CXClientData*) : u32 {

    translator := client_data as c2bJou*

    cursor.clangASTNodePrint(translator)

    visitor := translator.visitor_table[cursor.kind]

    visitor(cursor, parent, client_data)

    return 1
}

proc init_visitor_table(table : visitor_t[CXCursor_END_]) {
    table.fill(|table|, v_unimplemented)

    table[CXCursor_FunctionDecl]   = v_FunctionDecl
    table[CXCursor_ParmDecl]       = v_ParmDecl
#     table[CXCursor_CompoundStmt]   = v_CompoundStmt
#     table[CXCursor_IfStmt]         = v_IfStmt
#     table[CXCursor_BinaryOperator] = v_BinaryOperator
}

proc clangASTNodePrint(cursor : CXCursor, translator : c2bJou*) {
    name_str := ClangWrapper.getCursorName(cursor)
    kind_cxstr := clang.getCursorKindSpelling(cursor.kind)
    kind_str := clang.getCString(kind_cxstr)

    for i := 0; i < translator.indent; i += 1
        printf("  ")
    print "%: '%'", kind_str, name_str
}

proc v_unimplemented(cursor      : CXCursor,
                     parent      : CXCursor,
                     client_data : CXClientData*) : u32 {

    buff : char[1024]
    kind_cxstr := clang.getCursorKindSpelling(cursor.kind)
    kind_str := clang.getCString(kind_cxstr)

    buff.sprintf("c2bjou: missing visitor for %s", kind_str)

    panic(buff)

    return 0
}

proc v_CompoundStmt(cursor      : CXCursor,
                    parent      : CXCursor,
                    client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*
    
    # visit children
    translator.indent += 1
    translator.cw.traverse(cursor, dispatch, client_data)
    translator.indent -= 1
    
    return 1
}

proc v_FunctionDecl(cursor      : CXCursor,
                    parent      : CXCursor,
                    client_data : CXClientData*) : u32 {

    translator := client_data as c2bJou*

    name       := ClangWrapper.getCursorName(cursor)
    params     := [...ASTNode*]
    isVararg   := clang.Cursor_isVariadic(cursor) == 1
    retDecl    := (_nullptr() as ASTNode*)
    statements := [...ASTNode*]

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    c := 0
    while children[c].kind == CXCursor_ParmDecl {
        dispatch(children[c], cursor, client_data)
        params.push(translator.created.back())
        translator.created.pop()
        c += 1           
    }

    for c = c; c < |children|; c += 1 {
        dispatch(children[c], cursor, client_data)
        statements.push(translator.created.back())
        translator.created.pop()    
    }

    translator.indent -= 1

    # create result
    p := (_nullptr() as ASTNode*)
    
#     p := bjou_createProcedure(
#              my_data.name,
#              my_data.params.data(), |my_data.params|,
#              my_data.isVararg,
#              my_data.retDecl,
#              my_data.statements.data(), |my_data.statements|)

    translator.created.push(p)

    return 1
}

proc v_ParmDecl(cursor      : CXCursor,
                parent      : CXCursor,
                client_data : CXClientData*) : u32 {
    
    translator := client_data as c2bJou*

    name           := ClangWrapper.getCursorName(cursor)
    typeDeclarator := (_nullptr() as ASTNode*)
    initialization := (_nullptr() as ASTNode*)

    # visit children
    translator.indent += 1

    children := [...CXCursor]
    translator.cw.traverse(cursor, child_collector, (&children) as CXClientData*)

    if |children| != 0 panic("why does a param decl have children?")

    translator.indent -= 1
   
    cx_t := clang.getCursorType(cursor)
    typeDeclarator = tyToDecl(@translator, &cx_t)

    p := bjou_createParamDeclaration(
            name,
            typeDeclarator,
            initialization)

    translator.created.push(p)

    return 1  
}

proc tyToDecl(translator : c2bJou ref, t : CXType*) : ASTNode* {
    if translator.types.find(t).isnull()
        translator.types.insert(t, makeDeclFromTy(translator, t))
    return bjou_clone(translator.types[t])
}

proc makeDeclFromTy(translator : c2bJou ref, t : CXType*) : ASTNode* {
    name := ""

    if        t.kind == CXType_Void {
        name = "void" 
    } else if t.kind == CXType_Bool {
        name = "bool"
    } else if t.kind == CXType_Char_U {
        name = "u8"
    } else if t.kind == CXType_UShort {
        name = "u16"
    } else if t.kind == CXType_UInt {
        name = "u32"
    } else if t.kind == CXType_ULong or t.kind == CXType_ULongLong {
        name = "u64"
    } else if t.kind == CXType_Char_S {
        name = "i8"
    } else if t.kind == CXType_Short {
        name = "i16"
    } else if t.kind == CXType_Int {
        name = "i32"
    } else if t.kind == CXType_Long or t.kind == CXType_LongLong {
        name = "i64"
    } else if t.kind == CXType_Float {
        name = "f32"
    } else if t.kind == CXType_Double {
        name = "f64"
    } else panic("c2bjou: unable to translate type")

    id := bjou_createIdentifier(name)
    d  := bjou_createDeclarator(
            id,
            (_nullptr() as ASTNode*),
            (_nullptr() as char**), 0)

    return d
}

extern strcmp(char*, char*) : int

\op{ "=="
    proc (a : char*, b : char*) : bool
        return strcmp(a, b) == 0
}

\op{ "!="
    proc (a : char*, b : char*) : bool
        return not (a == b)
}

proc getBinOp(translator : c2bJou ref, cursor : CXCursor) : char* {
    tokens := translator.cw.getCursorTokens(cursor)

    cloc := clang.getCursorLocation(cursor)

    foreach t in tokens {
        tloc := clang.getTokenLocation(translator.cw.tu, t)
        cxs := clang.getTokenSpelling(translator.cw.tu, t)
        spl := clang.getCString(cxs)

        if clang.equalLocations(cloc, tloc) != 0
            print "%", spl
    }

    panic("c2bjou: did not find operator")

    return ""
}


